# Notes for Learn CPP

learn and gain from the source:

https://www.learncpp.com/cpp-tutorial

## 0.5 Compile & Run

> it translates your C++ source code into a machine language file called an object file. Object files are typically named name.o or name.obj, where name is the same name as the .cpp file it was produced from.
>
> So compile output `.o` or `.obj` machine code files
>
> After the compiler creates one or more object files, then another program called the linker kicks in. The job of the linker is three fold:
>
> 1. to take all the object files generated by the compiler and combine them into a single executable program.
>
> 2. the linker also is capable of linking library files. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. ex: C++ standard library
>
> 3. the linker __makes sure all cross-file dependencies are resolved properly__. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to a thing with the definition of that thing, you’ll get a linker error, and the linking process will abort.
>
> For complex projects, some development environments use a __makefile__, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways)

After `compile -> link` then the `.exe` or `a.out` is pop

## 0.x Mac Cmds

```sh
clang++ -std=c++11 -stdlib=libc++ 05.cpp
```

## 1.3 l-value vs r-value

> In C++, variables are a type of __l-value__. An l-value is a value that has a persistent address (in memory).
>
> Since all variables have addresses, all variables are l-values. The name l-value came about because l-values are the only values that can be on the left side of an assignment statement. __When we do an assignment, the left hand side of the assignment operator must be an l-value__. Consequently, a statement like 5 = 6; will cause a compile error, because 5 is not an l-value. The value of 5 has no memory, and thus nothing can be assigned to it. 5 means 5, and its value can not be reassigned. When an l-value has a value assigned to it, the current value at that memory address is overwritten.
>
> The opposite of l-values are __r-values__. An r-value refers to values that are not associated with a persistent memory address. Examples of r-values are single numbers (such as 5, which evaluates to 5) and expressions (such as 2 + x, which evaluates to the value of variable x plus 2). r-values are generally temporary in nature and are discarded at the end of the statement in which they occur


```cpp
int y;      // define y as an integer variable
y = 4;      // r-value 4 evaluates to 4, which is then assigned to l-value y
y = 2 + 5;  // r-value 2 + r-value 5 evaluates to r-value 7, which is then assigned to l-value y

int x;      // define x as an integer variable
x = y;      // l-value y evaluates to 7 (from before), which is then assigned to l-value x.
x = x;      // l-value x evaluates to 7, which is then assigned to l-value x (useless!)
x = x + 1;  // l-value x + r-value 1 evaluate to r-value 8, which is then assigned to l-value x.
```

## 1.3a cin, cout, endl

```cpp
#include <iostream>

std::cout << "Hello";
int x;
std::cin >> x;
std::count << "world" << x << std:endl;
```

## 1.4 caller vs callee

> The function initiating the function call is called the __caller__, and the function being called is the __callee__ or __called__ function.

```cpp
#include <iostream> // for std::cout and std::endl

// Definition of function doPrint()
// doPrint() is the __called__ or __callee__ function
void doPrint()
{
    std::cout << "In doPrint()" << std::endl;
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()" << std::endl;
    doPrint();
    // Interrupt main() by making a function call to doPrint().
    // main() is the caller.
    std::cout << "Ending main()" << std::endl;

    return 0;
}
```

## 1.41 why main have return type `int`

> You now have the conceptual tools to understand how the `main()` function actually works. When the program is executed, the operating system makes a function call to `main()`.
>
> Execution then jumps to the top of `main`. The statements in main are executed sequentially. Finally, __`main` returns an integer value (usually 0) back to the operating system__. This is why main is defined as `int main()`.
>
> Why return a value back to the operating system?
>
> __This value is called a status code, and it tells the operating system (and any other programs that called yours) whether your program executed successfully or not__.

__By consensus, a return value of 0 means success, and a positive return value means failure__.

```sh
» ls -al
total 56
drwxr-xr-x   5 james_yang  staff    170 Dec  1 11:24 .
drwxr-xr-x  58 james_yang  staff   1972 Dec  1 10:50 ..
-rw-r--r--   1 james_yang  staff    167 Dec  1 11:15 05.cpp
-rw-r--r--@  1 james_yang  staff   4713 Dec  1 11:24 NOTES.md
-rwxr-xr-x   1 james_yang  staff  16120 Dec  1 11:13 a.out
» echo $?
0
# ^ exit status 0 means success
```

if a function has a non-void return type, it must return a value of that type (using a return statement). The only exception to this rule is for function `main()`, __which will assume a return value of 0 if one is not explicitly provided__.


## 1.42 No Nested Function

Functions can not be defined inside other functions (called nesting) in C++.

## 1.43 quiz

```cpp
#include <iostream>
void printA()
{
    std::cout << "A" << std::endl;
}

int main()
{
    std::cout << printA() << std::endl;

    return 0;
}
```

^ does not compile. __Function `printA()` returns `void`, which main tries to send to `std::cout`. This will produce a compile error__.


## 1.4c key word

https://www.learncpp.com/cpp-tutorial/14c-keywords-and-naming-identifiers/

## 1.5a operand and operator

> __Literals, variables, and function calls__ that return values are all known as __operands. Operands supply the data__ that the expression works with.
>
> __Operators tell the expression how to combine one or more operands to produce a new result__. For example, in the expression `3 + 4`, the `+` is the plus operator

Operators come in three types:

- Unary operators act on one operand. An example of a unary operator is the `-` operator. In the expression `-5`, the `-` operator is only being applied to one operand `5` to produce a new value `-5`.

- Binary operators act on two operands (known as left and right). An example of a binary operator is the + operator. In the expression `3 + 4`, the `+` operator is working with a left operand `3` and a right operand `4` to produce a new value `7`.

- Ternary operators act on three operands. There is only one of these in C++, which we’ll cover later.

## 1.7 Forward declarations and definitions

```cpp
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

then output:

```sh
add.cpp(5) : error C3861: 'add': identifier not found
add.cpp(9) : error C2365: 'add' : redefinition; previous definition was 'formerly unknown identifier'
```

> When the compiler reaches the function call to `add()` on line 5 of `main()`, it doesn’t know what add is, because we haven’t defined `add()` until line 9! That produces the first error __identifier not found__.

Reorder is not good idea when the orders are matter.

A __forward declaration__ allows us to tell the compiler about the existence of an identifier before actually defining the identifier.

```cpp
#include <iostream>

int add(int x, int y);
// forward declaration of add() (using a function prototype)

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl; // this works because we forward declared add() above
    return 0;
}

int add(int x, int y) // even though the body of add() isn't defined until here
{
    return x + y;
}
```

what happens if we forward declare a function but do not define it?

> it depends.
>
> If a forward declaration is made, but the function is never called, the program will compile and run fine.
>
> However, if a forward declaration is made, the function is called, but the program never defines the function, the program will compile okay, __but the linker will complain that it can’t resolve the function call__.

```cpp
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

## 1.71 Declarations vs. definitions

> A __definition__ actually implements or instantiates (causes memory to be allocated for) the identifier.
>
> __A definition is needed to satisfy the linker. If you use an identifier without providing a definition, the linker will error__.
>
> A __declaration__ is a statement that tells the compiler about the existence of an identifier (variable or function name) and its type. Here are some examples of declarations:
>
> __A declaration is all that is needed to satisfy the compiler. If you use an identifier without providing a declaration, the compiler will error__.

## 1.8a Naming Confliction

C++ requires that all identifiers __variable and/or function names__ be non-ambiguous.

> Rule: When you use an identifier in a namespace, you always have to identify the namespace along with the identifier
>
> The most straightforward way to tell the compiler that cout lives in the std namespace is by using the `std::` prefix. For example:

```cpp
std::cout << "Hello world!";
```

So the same name identifier would not conflict.

## 1.9 Header File

> __Header guards__ prevent a given header file from being #included more than once in the same file.

```cpp
// add.h
// This is start of the header guard.  
// ADD_H can be any unique name.  
// By convention, we use the name of the header file.
#ifndef ADD_H
#define ADD_H

// This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!

// This is the end of the header guard
#endif
```
> Why doesn’t `iostream` have a `.h` extension?

The answer is, because `iostream.h` is a different header file than `iostream` is! To explain requires a very short history lesson.

The original version of cout and cin lived in iostream.h. When the language was standardized by the ANSI committee, they decided to move all of the functions in the runtime library into the `std` namespace (which is generally a good idea). However, this presented a problem: __if they moved all the functions into the std namespace, none of the old programs would work any more!__

To try to get around this issue and provide backwards compatibility for older programs, a new set of header files was introduced that use the same names __but lack the `.h` extension__. These new header files have all their functionality inside the std namespace.

This way, older programs that include `#include <iostream.h>` do not need to be rewritten, and newer programs can `#include <iostream>`.

#### Including header files from other directories

One (bad) way to do this is to include a relative path to the header file you want to include as part of the `#include` line. For example:

```cpp
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

The downside of this approach is that it requires you to reflect your directory structure in your code.

Using g++, you can use the `-I` option to specify __an alternate include directory__.

```cpp
g++ -o main -I /source/includes main.cpp
```

#### Can I put function or variable definitions in a header file?

> You shouldn’t, as it may cause linker errors. We’ll explain why in the upcoming lesson on header guards.


## 1.10 Preprocesssor

When the preprocessor runs, it simply scans through each code file from top to bottom, looking for directives. __Directives are specific instructions that start with a `#` symbol and end with a newline (NOT a semicolon)__.

The preprocessor is not smart -- it does not understand C++ syntax; rather, it simply manipulates text before the compiler runs. The output of the preprocessor is then sent to the compiler.

> __Note that the preprocessor does not modify the original code files in any way rather, all text changes made by the preprocessor happen temporarily in-memory__.

The `#define` directive can be used to create a macro. __A macro is a rule that defines how an input sequence (e.g. an identifier) is converted into a replacement output sequence (e.g. some text)__.

There are two basic types of macros: `object-like macros`, and `function-like macros`.


Function-like macros act like functions, and serve a similar purpose. We will not discuss them, __because their use is generally considered dangerous, and almost anything they can do can be done by an (inline) function__.

Object-like macros can be defined in one of two ways:

```cpp
#define identifier
#define identifier substitution_text
```

#### Object-like macros with substitution text

```cpp
#define MY_FAVORITE_NUMBER 9
std::cout << "My favorite number is: " << MY_FAVORITE_NUMBER << std::endl;

// preproceed to
std::cout << "My favorite number is: " << 9 << std::endl;
```

__We discuss this case (and why you shouldn’t use it) in more detail in section 2.9__

#### Object-like macros without substitution text

```cpp
#define USE_YEN
```

any further occurrence of the identifier is removed and replaced by nothing! This might seem pretty useless, and it is for doing text substitution.

__Unlike object-like macros with substitution text, macros of this form are generally considered acceptable to use.__

#### Conditional compilation

```cpp
// define as nothing
#define PRINT_JOE

#ifdef PRINT_JOE
std::cout << "Joe" << std::endl;
#endif

#ifdef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif

#ifndef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif
```

> Since we defined `PRINT_JOE` to be __nothing__, how come the preprocessor didn’t replace `PRINT_JOE` in `#ifdef PRINT_JOE` with __nothing__?

__Macros only cause text substitution for normal code. Other preprocessor commands are ignored__.

```cpp
#define FOO 9 // Here's a macro substitution

// This FOO does not get replaced
// because it’s part of preprocessor directive
#ifdef FOO
    std::cout << FOO;
    // This FOO gets replaced with 9
    // because it's part of the normal code
#endif
```

#### The scope of defines

Directives are resolved before compilation, __from top to bottom on a file-by-file basis__. __Once the preprocessor has finished, all directives from that file are discarded__.

```cpp
// function.cpp
#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!";
#endif
#ifndef PRINT
    std::cout << "Not printing!";
#endif
}

// main.cpp
void doSomething(); // forward declaration for function doSomething()

int main()
{
#define PRINT

    doSomething();

    return 0;
}

// output: Not printing!
```

## 1.10a Header guards

```cpp
//math.h:
int getSquareSides()
{
    return 4;
}

//geometry.h:
#include "math.h"


//main.cpp:
#include "math.h"
#include "geometry.h"

int main()
{
    return 0;
}
```

`main.cpp #includes math.h`, which copies the definition for function `getSquareSides` into main.cpp.

Then `main.cpp #includes geometry.h`, which `#includes math.h` itself. This copies the definition for function `getSquareSides` into `geometry.h`, which then gets copied into `main.cpp`.

Thus, after resolving all of the `#includes` by preprocessor, `main.cpp` ends up looking like this:

Duplicate definitions and a compile error

```cpp
int getSquareSides()  // from math.h
{
    return 4;
}

int getSquareSides() // from geometry.h
{
    return 4;
}

int main()
{
    return 0;
}
```

#### Header Guards

Header guards are conditional compilation directives:

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations and definitions here

#endif
```

typically the name of the header file with a `_H` appended to it is used. For example, `math.h` would have the header guard

```cpp
// math.h
#ifndef MATH_H
#define MATH_H

int getSquareSides()
{
    return 4;
}

#endif
```

Then previous example can be resolved by:

```cpp
// math.cpp
#ifndef MATH_H
#define MATH_H

int getSquareSides()
{
    return 4;
}

#endif

// geometry.h
#ifndef GEOMETRY_H
#define GEOMETRY_H

#include "math.h"

#endif

// main.cpp
#include "math.h"
#include "geometry.h"

int main()
{
    return 0;
}
```

#### Can’t we just avoid definitions in header files?

There are quite a few cases we’ll show you in the future where it’s desirable to put definitions in a header file, for example, when it comes to __user-defined types (such as structs and classes)__.

Header guards __do not prevent a given header file from being included (once) into different code files__. This can cause unexpected problems. Consider:


```cpp
// square.h:
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif

// square.cpp
#include "square.h"  // square.h is included once here

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}

// main.cpp
#include <iostream>
#include "square.h" // square.h is also included once here

int main()
{
    std::cout << "a square has " << getSquareSides() << " sides" << std::endl;
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << std::endl;

    return 0;
}
```

When `square.h` is included from `square.cpp`, `SQUARE_H` is __defined until the end of `square.cpp`__.

This define prevents `square.h` from being included into `square.cpp` a second time (which is the point of header guards).

__However, once `square.cpp` is finished, `SQUARE_H` is no longer considered defined__. (preprocessor is file-by-file based text subtitution)

__This means that when the preprocessor runs on `main.cpp`, `SQUARE_H` is not initially defined in `main.cpp`__.

> The end result is that both `square.cpp` and `main.cpp` get a copy of the definition of `getSquareSides()`.

This program will compile, but the linker will complain about your program having __multiple definitions for identifier `getSquareSides`__!

The workaround solution is to change that definition as forward declaration in root base header file, __so let the later included header file implement it__.

```cpp
// square.h:
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides(); // forward declaration for getSquareSides
int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif

// square.cpp:
// It would be okay to #include square.h here if needed
// This program doesn't need to.

int getSquareSides() // actual definition for getSquareSides
{
    return 4;
}

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}

// main.cpp
#include <iostream>
#include "square.h" // square.h is also included once here

int main()
{
    std::cout << "a square has " << getSquareSides() << "sides" << std::endl;
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << std::endl;

    return 0;
}
```

## 2.1 Variable

#### Initialization

1. copy initialization

    ```cpp
    int nValue = 5; // copy initialization
    ```

2. direct initialization by using parenthesis

    ```cpp
    int nValue(5); // direct initialization
    ```

    Consequently, we recommend using direct initialization over copy initialization.

3. Uniform initialization in C++11

    ```cpp
    int value{5}; // uniform initialization

    int value{}; // default initialization to 0
    ```

    Initializing a variable with an empty brace indicates default initialization. __Default initialization initializes the variable to zero (or empty, if that’s more appropriate for a given type)__.

    Uniform initialization has the added benefit of __disallowing “narrowing” type conversions__. This means that if you try to use uniform initialization to initialize a variable with a value it can not safely hold, the compiler will throw an warning or error. For example:

    ```cpp
    int value{4.5}; // error: an integer variable can not hold a non-integer value
    ```

    If you’re using a C++11 compatible compiler, __favor uniform initialization__.

#### Variable assignment

When a variable is given a value after it has been defined, it is called a __copy assignment__ (or assignment for short).

```cpp
int nValue;
nValue = 5; // copy assignment
```

C++ does not provide any built-in way to do a direct or uniform assignment.

#### Uninitialized variables

In C++, a fundamental variable that is uninitialized will have a garbage value until you assign a valid one.

Rule: __Always initialize your fundamental variables, or assign a value to them as soon as possible after defining them__.

#### Defining multiple variables

It is possible to define multiple variables of the same type in a single statement by separating the names with a comma.

```cpp
int a, b;
int a = 5, b = 6;
int c(7), d(8);
int e{9}, f{10};

int a, b = 5; // wrong (a is uninitialized!)

int a= 5, b= 5; // correct

int a, b(5);
int c, d{5};
// better help if using uniform/direct initialization
```

In the top statement, variable `a` will __be left uninitialized, and the compiler may or may not complain__. But may leads problem.

#### Where to define variables

Older C compilers forced users to define all of the variables in a function at the top of the function:

```cpp
int main()
{
    // all variable up top
    int x;
    int y;

    // then code
    std::cout << "Enter a number: ";
    std::cin >> x;

    std::cout << "Enter another number: ";
    std::cin >> y;

    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```

This style is now obsolete. C++ compilers do not require all variables to be defined at the top of a function.

__The proper C++ style is to define variables as close to the first use of that variable as you reasonably can__:

```cpp
int main()
{
    std::cout << "Enter a number: ";
    int x; // we need x on the next line, so we'll declare it here, as close to its first use as we reasonably can.
    std::cin >> x; // first use of x

    std::cout << "Enter another number: ";
    int y; // we don't need y until now, so it gets declared here
    std::cin >> y; // first use of y

    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```

__Rule: Define variables as close to their first use as you reasonably can__.

## 2.2 Void

In C, as a way to indicate that a function does not take any parameters:

```cpp
int getValue(void)
// void here means no parameters
// is necessary for c program
{
    int x;
    std::cin >> x;
    return x;
}
```

The explicit use of keyword void to mean __no parameters__ is a holdover from C, and is not required in C++.

The following code is equivalent, and preferred in C++:

```cpp
int getValue()
// empty function parameters is an implicit void
{
    int x;
    std::cin >> x;
    return x;
}
```

## 2.4 Sizeof and Integer

0. `char` is to be minimum 1 byte.

1. `short` is ensure to be minimum 2 bytes, which is 16 bits.

2. `int` is ensure to be minimum 2 bytes, but usually 4 bytes on modern architectures.

3. `long` is surprise to minimum 4 bytes, rather than java's 8 bytes.

4. `long long` in C99/C++11 type is 8 bytes.

#### What is size_t?

`sizeof` (and many functions that return a size or length value) return a value of type `size_t`.

`size_t` is an __unsigned, integral value that is typically used to represent the size or length of objects__.

Amusingly, we can use `sizeof` (__which returns a value of type `size_t`__) to ask for the size of `size_t` itself:

```cpp
#include <iostream>
int main()
{
  std::cout << sizeof(size_t);

  return 0;
}
```

Compiled as a 32-bit (4 byte) console app on the author’s system, this prints `4`.

That is, for 32-bit applications, `size_t` will typically be a 32 bit unsigned integer, and for a 64-bit application, `size_t` will typically be a 64-bit unsigned integer.

__`size_t` is defined to be big enough to hold the size of the largest object creatable on your system (in bytes)__.

By definition, any object larger than the largest value `size_t` can hold is __considered ill-formed (and will cause a compile error), as the `sizeof` operator would not be able to return the size without overflow__.

## 2.4a Fixed-width integers and the unsigned controversy

The short, non-technical answer is that this goes back to C, when performance was of utmost concern. __C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for `int` that performs best on the target computer architecture__.

#### Fixed-width integers

To help with cross-platform portability, C99 defined a set of __fixed-width__ integers (in the `stdint.h` header) that are guaranteed to have the same size on any architecture.

```cpp
int8_t	     1 byte signed
uint8_t	     1 byte unsigned
int16_t	     2 byte signed
uint16_t     2 byte unsigned
int32_t	     4 byte signed
uint32_t     4 byte unsigned
int64_t	     8 byte signed
uint64_t     8 byte unsigned
```

C++ officially adopted these fixed-width integers as part of C++11.

They can be accessed by including the `cstdint` header, where they are defined inside the `std` namespace. Here’s an example:

```cpp
#include <iostream>
#include <cstdint>

int main()
{
    std::int16_t i(5); // direct initialization
    std::cout << i;
    return 0;
}
```

#### Warning: `int8_t` and `uint8_t` may or may not behave like `char`

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    int8_t myint = 65;
    std::cout << myint;

    return 0;
}
```

Most compilers define and treat `int8_t` and `uint8_t` identically to types `signed char` and `unsigned char` respectively, but this is not required.

On most systems, this program will print `A` (treating `myint` as a `char`). __However, on some systems, this may print `65` as expected__.

> For simplicity, __it’s best to avoid `int8_t` and `uint8_t` altogether (use `int16_t` or `uint16_t` instead)__.
>
> However, if you do use `int8_t` or `uint8_t`, __you should be careful of any function that would interpret `int8_t` or `uint8_t` as a `char` instead of an integer (this includes `std::cout` and `std::cin`)__.

__Rule: Avoid `int8_t` and `uint8_t`. If you do use them, note that they are often treated like chars__.

#### The downsides of fixed-width integers

Fixed-width integers may not be supported on architectures where those types can’t be represented. They may also be less performant than the built-in types on some architectures.

To help address the above downsides, C++11 also defines two alternative sets of fixed-width integers.

#### Fast and least

The fast type (`int_fast#_t`) __gives you an integer that’s the fastest type with a width of at least # bits (where # = 8, 16, 32, or 64)__. For example, `int_fast32_t` will give you the fastest integer type that’s at least 32 bits.

The least type (`int_least#_t`) __gives you the smallest integer type with a width of at least # bits (where # = 8, 16, 32, or 64)__. For example, `int_least32_t` will give you the smallest integer type that’s at least 32 bits.

#### The controversy over unsigned numbers

Many developers (and some large development houses, such as Google) believe that developers should generally avoid unsigned integers.

__This is largely because unexpected behavior can result when you mix signed and unsigned integers__.

```cpp
void doSomething(unsigned int x)
{
    // Run some code x times
}

int main()
{
    doSomething(-1);
}
// -1 gets converted to some large number (probably 4294967295)
```

## 2.5 floating point

`long double` minimum size to 8 bytes, typically can be 8, 12, or 16 bytes.

#### NaN and Inf

The first is Inf, which represents infinity. `Inf` can be positive or negative. The second is `NaN`, which stands for “Not a Number”.

```cpp
include <iostream>

int main()
{
    double zero = 0.0;
    double posinf = 5.0 / zero; // positive infinity
    std::cout << posinf << std::endl;

    double neginf = -5.0 / zero; // negative infinity
    std::cout << neginf << std::endl;

    double nan = zero / zero; // not a number (mathematically invalid)
    std::cout << nan << std::endl;

    return 0;
}
// 1.#INF
// -1.#INF
// 1.#IND
```

`INF` stands for infinity, and `IND` stands for indeterminate. Note that the results of printing `Inf` and `NaN` are platform specific, so your results may vary.

## 2.9 Const, constexpr, and symbolic constants

#### Const

run-time constant use `const`:

```cpp
std::cout << "Enter your age: ";
int age;
std::cin >> age;

const int usersAge (age); // usersAge can not be changed

// Const is used most often with function parameters:
void printInteger(const int myValue)
{
    std::cout << myValue;
}
```

`usersAge` relies on user input (which can only be given at runtime) and `myValue` depends on the value passed into the function (which is only known at runtime).

Making a function parameter const does two things.

1. it tells the person calling the function that the function will not change the value of myValue.
2. it ensures that the function doesn’t change the value of `myValue` (if `myValue` is a reference).

#### Constexpr

C++ actually has two different kinds of constants.

Because a `const` value could be either runtime or compile-time, the compiler has to keep track of which kind of constant it is.

To help provide more specificity, C++11 introduced new keyword `constexpr`, __which ensures that the constant must be a compile-time constant__:

```cpp
constexpr double gravity (9.8); // ok, the value of 9.8 can be resolved at compile-time
constexpr int sum = 4 + 5; // ok, the value of 4 + 5 can be resolved at compile-time

std::cout << "Enter your age: ";
int age;
std::cin >> age;
constexpr int myAge = age; // not okay, age can not be resolved at compile-time
```

#### Using symbolic constants throughout a program

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

// define your own namespace to hold constants
namespace constants
{
    constexpr double pi(3.14159);
    constexpr double avogadro(6.0221413e23);
    constexpr double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
    // ... other related constants
}
#endif

// main.cpp
#include "constants.h"
double circumference = 2 * radius * constants::pi;
```

## 3.8a Bit flags and bit masks

#### Bit flags

However, in some storage-intensive cases, it can be useful to `pack` 8 individual boolean values into a single byte for storage efficiency purposes.

This is done by using the bitwise operators to set, clear, and query individual bits in a byte, __treating each as a separate boolean value__. These individual bits are called bit flags.

#### Defining bit flags in C++14

Because C++14 supports binary literals, this is easiest in C++14:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 0b0000'0001; // represents bit 0
const unsigned char option1 = 0b0000'0010; // represents bit 1
const unsigned char option2 = 0b0000'0100; // represents bit 2
const unsigned char option3 = 0b0000'1000; // represents bit 3
const unsigned char option4 = 0b0001'0000; // represents bit 4
const unsigned char option5 = 0b0010'0000; // represents bit 5
const unsigned char option6 = 0b0100'0000; // represents bit 6
const unsigned char option7 = 0b1000'0000; // represents bit 7
```

#### Defining bit flags in C++11 or earlier

use hex:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 0x1; // hex for 0000 0001
const unsigned char option1 = 0x2; // hex for 0000 0010
const unsigned char option2 = 0x4; // hex for 0000 0100
const unsigned char option3 = 0x8; // hex for 0000 1000
const unsigned char option4 = 0x10; // hex for 0001 0000
const unsigned char option5 = 0x20; // hex for 0010 0000
const unsigned char option6 = 0x40; // hex for 0100 0000
const unsigned char option7 = 0x80; // hex for 1000 0000
```

or left-shift operator:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 1 << 0; // 0000 0001
const unsigned char option1 = 1 << 1; // 0000 0010
const unsigned char option2 = 1 << 2; // 0000 0100
const unsigned char option3 = 1 << 3; // 0000 1000
const unsigned char option4 = 1 << 4; // 0001 0000
const unsigned char option5 = 1 << 5; // 0010 0000
const unsigned char option6 = 1 << 6; // 0100 0000
const unsigned char option7 = 1 << 7; // 1000 0000
```

#### Turning individual bits on

To set a bit (turn on), we use bitwise OR equals (operator |=):

```cpp
unsigned char myflags = 0; // all bits turned off to start

myflags |= option4;
// turn option 4 on
myflags |= (option4 | option5);
// turn options 4 and 5 on at the same time

myflags &= ~option4;
// turn option 4 off
myflags &= ~(option4 | option5);
// turn options 4 and 5 off at the same time

myflags ^= option4;
// flip option4 from on to off, or vice versa
myflags ^= (option4 | option5);
// flip options 4 and 5 at the same time

// Determining if a bit is on or off
if (myflags & option4)
    std::cout << "myflags has option 4 set";
if (!(myflags & option5))
    std::cout << "myflags does not have option 5 set";
```

#### An introduction to std::bitset

```cpp
#include <bitset>

std::bitset<8> bits; // we need 8 bits

// initialized with an initial set of values:
std::bitset<8> bits(option1 | option2);
// start with option 1 and 2 turned on

std::bitset<8> morebits(0x3);
// start with bit pattern 0000 0011
```

`std::bitset` provides 4 key functions: `test`, `flip`, `set`, `reset`:

```cpp
#include <bitset>
#include <iostream>

// Note that with std::bitset, our options correspond to bit indices, not bit patterns
const int option0 = 0;
const int option1 = 1;
const int option2 = 2;
const int option3 = 3;
const int option4 = 4;
const int option5 = 5;
const int option6 = 6;
const int option7 = 7;

int main()
{
    std::bitset<8> bits(0x2); // we need 8 bits, start with bit pattern 0000 0010
    bits.set(option4); // set bit 4 to 1 (now we have 0001 0010)
    bits.flip(option5); // flip bit 5 (now we have 0011 0010)
    bits.reset(option5); // set bit 5 back to 0 (now we have 0001 0010)

    std::cout << "Bit 4 has value: " << bits.test(option4) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option5) << '\n';
    std::cout << "All the bits: " << bits << '\n';

    return 0;
}
```

#### bit mask

When we __bundle individual bits together for the purpose of modifying them as a group__, this is called a bit mask.

```cpp
#include <iostream>

int main()
{
    const unsigned int lowMask = 0xF; // bit mask to keep low 4 bits (hex for 0000 0000 0000 1111)

    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;

    num &= lowMask; // remove the high bits to leave only the low bits

    std::cout << "The 4 low bits have value: " << num << '\n';

    return 0;
}

// Enter an integer: 151
// The 4 low bits have value: 7
```

Example: RGBA example:

RGBA need 8-bit unsigned integer each hue. so a 32-bit RGBA value represent it.

```cpp
#include <iostream>
int main()
{
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;

    std::cout << "Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex allows us to read in a hex value

    // use bitwise AND to isolate red pixels, then right shift the value into the range 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;

    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";

    return 0;
}

//Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): FF7F3300
//Your color contains:
//255 of 255 red
//127 of 255 green
//51 of 255 blue
//0 of 255 alpha
```

## 4.1a Local variables, scope, and duration

#### block

A block of statements, also called a compound statement, is a group of statements that is treated by the compiler as if it were a single statement. Blocks begin with a `{` symbol, end with a `}` symbol.

__blocks__ allow multiple statements to be used wherever a single statement can normally be used. They are extremely useful when you need a set of statements to execute together.

#### scope and duration

A variable’s `scope` determines where a variable is accessible. __A variable’s `duration` determines where it is created and destroyed__. The two concepts are often linked

Local variables have __automatic duration__, which means they are created (and initialized, if relevant) at the point of definition, and destroyed when the block they are defined in is exited.

Local variables have __block scope (also called local scope)__, which means they enter scope at the point of declaration __and go out of scope at the end of the block that they are defined in__.

```cpp
int main() // outer block
{
    int n(5); // n created and initialized here

    { // begin nested block
        double d(4.0); // d created and initialized here
    } // d goes out of scope and is destroyed here

    // d can not be used here because it was already destroyed!

    return 0;
} // n goes out of scope and is destroyed here
```

Variables __defined inside a block can only be seen within that block__.

#### Shadowing

Note that a variable inside a nested block can have the same name as a variable inside an outer block. When this happens, the nested variable “hides” the outer variable. This is called __name hiding__ or __shadowing__.

> Rule: Avoid using nested variables with the same names as variables in an outer block.
>
> Variables should be defined in the most limited scope possible

Although function parameters are not defined inside the block belonging to the function, in most cases, they can be considered to have block scope.

> The exception case is for __function-level exceptions__ (think about scala annotation `@throws(classOf[Exception])` on method definition)

## 4.2 Global variables and linkage

Variables declared outside of a function are called global variables.

Global variables have __static duration__, which means they are created when the program starts and are destroyed when it ends. Global variables have __file scope (also informally called “global scope” or “global namespace scope”)__, which means they are visible until the end of the file in which they are declared.

The global scope operator (`::`) can be used to tell the compiler you mean the global version instead of the local version.

```cpp
#include <iostream>
int value(5); // global variable

int main()
{
    int value = 7; // hides the global variable value
    value++; // increments local value, not global value
    ::value--; // decrements global value, not local value

    std::cout << "global value: " << ::value << "\n";
    std::cout << "local value: " << value << "\n";
    return 0;
} // local value is destroyed
```

#### linkage

In addition to scope and duration, variables have a third property: linkage. A variable’s linkage __determines whether multiple instances of an identifier refer to the same variable or not__.


A variable with no linkage can only be referred to from the limited scope it exists in.

Normal local variables are an example of variables with no linkage.

__Two local variables with the same name but defined in different functions have no linkage__ -- each will be considered an independent variable.

#### internal linkage

A variable with internal linkage is called an __internal variable (or static variable)__. Variables with internal linkage can be used anywhere __within the file they are defined in, but can not be referenced outside the file they exist in__.

we can use the `static` keyword to make a global variable internal (able to be used only within a single file):

```cpp
static int g_x; // g_x is static, and can only be used within this file

int main()
{
    return 0;
}
```

#### external linkage

A variable with external linkage is called an external variable. Variables with external linkage can be used both in the file they are defined in, as well as in other files.

we can use the `extern` keyword to do so

```cpp
extern double g_y(9.8); // g_y is external, and can be used by other files

// Note: those other files will need to use a forward declaration to access this external variable
// We'll discuss this in the next section

int main()
{
    return 0;
}
```

By default, __non-const variables declared outside of a function are assumed to be external. However, const variables (with `const` keyword) declared outside of a function are assumed to be internal__.

### Variable forward declarations via the extern keyword

Similarly to use a function forward declaration, in order to use an external global variable that has been declared in another file, __you must use a variable forward declaration__.

__For variables, creating a forward declaration is done via the `extern` keyword (with no initialization value)__.

```cpp
/* global.cpp */
// define two global variables
// non-const globals have external linkage by default
int g_x; // external linkage by default
extern int g_y(2); // external linkage by default, so this extern is redundant and ignored

// in this file, g_x and g_y can be used anywhere beyond this point

/* main.cpp */
extern int g_x; // forward declaration for g_x (defined in global.cpp) -- g_x can now be used beyond this point in this file

int main()
{
    extern int g_y; // forward declaration for g_y (defined in global.cpp) -- g_y can be used beyond this point in main() only

    g_x = 5;
    std::cout << g_y; // should print 2

    return 0;
}
```

> Note that this means the `extern` keyword has different meanings in different contexts.
>
> In some contexts, extern means “give this variable external linkage”.
>
> In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.

If the variable forward declaration is __declared outside of a function, it applies for the whole file__. If the variable forward declaration is declared __inside a function, it applies within that block only__.

> If a variable is declared as __static__, trying to use a forward declaration to access it will not work:

```cpp
// constants.cpp:
static const double g_gravity(9.8);

// main.cpp
#include <iostream>

extern const double g_gravity; // This will satisfy the compiler that g_gravity exists

int main()
{
    std:: cout << g_gravity; // This will cause a linker error because the only definition of g_gravity is inaccessible from here
    return 0;
}
```

### Function linkage

Functions have the same linkage property that variables do.

__Functions always default to external linkage, but can be set to internal linkage via the `static` keyword__:

```cpp
// This function is declared as static, and can now be used only within this file
// Attempts to access it via a function prototype will fail
static int add(int x, int y)
{
    return x + y;
}
```

#### The one-definition rule and non-external linkage

We noted that the one-definition rule says that an object or function can’t have more than one definition, either within a file or a program.

It’s worth noting that __non-extern objects and functions in different files are considered to be different entities__, even if their names and types are identical. This makes sense, since they can’t be seen outside of their respective files anyway.

#### File scope vs. global scope

Technically, in C++, all global variables in C++ have __file scope__.

Informally, the term __file scope is more often applied to file scope variables with internal linkage only__, and __global scope” to file scope variables with external linkage__.

#### Global symbolic constants

A symbolic constant is a name given to a constant literal value.

```cpp
#define MAX_STUDENTS_PER_CLASS 30
#define MAX_NAME_LENGTH 30

int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;
setMax(MAX_NAME_LENGTH);
```
In this case, it’s clear that `MAX_STUDENTS_PER_CLASS` and `MAX_NAME_LENGTH` are intended to be independent values, even though they happen to share the same value `30`.

#### why not use `#define` symbolic constant

> `#defined` symbolic constants do not show up in the debugger (which shows you your actual code). So although the compiler would compile:
> `int max_students = numClassrooms * 30;`
>
> in the debugger you’d see:
> `int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;`
>
> `#defined` values always have file scope (which we’ll talk more about in the section on local and global variables).
>
> This means a value #defined in one piece of code may have a naming conflict with a value `#defined` within the same file later.

1. naming confliction in same file.
2. debug hard, have to lookup where it defined.

> Rule: Avoid using #define to create symbolic constants

A better way to create symbolic constants is through use of `const` (or better, `constexpr`) variables:

```cpp
constexpr int maxStudentsPerClass { 30 };
constexpr int maxNameLength { 30 }

// These will show up in the debugger, and follow all of the normal variable rules around scope.
```

> Rule: use const variables to provide a name and context for your magic numbers.

#### Global symbolic constants

In section 2.9

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

// define your own namespace to hold constants
namespace Constants
{
    const double pi(3.14159);
    const double avogadro(6.0221413e23);
    const double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
    // ... other related constants
}
#endif
```

While this is simple (and fine for smaller programs), every time `constants.h` gets `#included` into a different code file, __each of these variables is copied into the including code file__.

We can avoid this problem __by turning these constants into const global variables, and changing the header file to hold only the variable forward declarations__:

```cpp
// constants.cpp:
namespace Constants
{
    // actual global variables
    extern const double pi(3.14159);
    extern const double avogadro(6.0221413e23);
    extern const double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
}

// constans.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace Constants
{
    // forward declarations only
    extern const double pi;
    extern const double avogadro;
    extern const double my_gravity;
}

#endif

// main.cpp
include "constants.h"
double circumference = 2 * radius * Constants::pi;
```

Because global symbolic constants __should be namespaced (to avoid naming conflicts with other identifiers in the global namespace) and are read-only__, the use of the `g_` prefix is not necessary.

Now the symbolic constants will get instantiated only once (in `constants.cpp`), instead of once every time `constants.h` is `#included`, and the other uses will simply refer to the version in `constants.cpp`.

Any changes made to `constants.cpp` will require recompiling only `constants.cpp`.

However, there are a couple of downsides to doing this.

1. These constants are now considered compile-time constants only within the file they are actually defined in (`constants.cpp`), not anywhere else they are used (now as `run-time constant`).

__This means that outside of `constants.cpp`, they can’t be used anywhere that requires a compile-time constant__(such as for the length of a fixed array).

2. the compiler may not be able to optimize these as much.

> Given the above downsides, we recommend defining your constants in the header file. If you find that for some reason those constants are causing trouble, you can move them into a `.cpp` file as per the above as needed.

#### Summary

```cpp
// Uninitialized definition:
int g_x;        // defines uninitialized global variable (external linkage)
static int g_x; // defines uninitialized static variable (internal linkage)
const int g_x;  // not allowed: const variables must be initialized

// Forward declaration via extern keyword:
extern int g_z;       // forward declaration for global variable defined elsewhere
extern const int g_z; // forward declaration for const global variable defined elsewhere

// Initialized definition:
int g_y(1);        // defines initialized global variable (external linkage)
static int g_y(1); // defines initialized static variable (internal linkage)
const int g_y(1);  // defines initialized const variable (internal linkage)

// Initialized definition w/extern keyword:
extern int g_w(1);       // defines initialized global variable (external linkage, extern keyword is redundant in this case)
extern const int g_w(1); // defines initialized const global variable (external linkage)
```

## 4.3 Static duration variables

Using the `static` keyword on local variables changes them __from automatic duration to static duration (also called fixed duration)__.

A static duration variable (also called a “static variable”) is one that retains its value even after the scope in which it has been created has been exited!

__Static duration variables are only created (and initialized) once, and then they are persisted throughout the life of the program__.

```cpp
#include <iostream>

void incrementAndPrint()
{
    static int s_value = 1;     // static duration via static keyword.  This line is only executed once.
    ++s_value;
    std::cout << s_value << '\n';
} // s_value is not destroyed here, but becomes inaccessible

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();

    return 0;
}

// output:
// 2
// 3
// 4
```

## 4.3 Scope, duration, and linkage summary

https://www.learncpp.com/cpp-tutorial/4-3a-scope-duration-and-linkage-summary/

^ A must-check list.

## 4.3b Namespace

A naming conflict occurs when two identifiers are introduced into the same scope, and the compiler can’t disambiguate which one to use.

A __namespace defines an area of code in which all identifiers are guaranteed to be unique__. By default, global variables and normal functions are defined in the global namespace.

Accessing a namespace with the scope resolution operator `::`.

Multiple namespace blocks with the same name allowed

```cpp
// add.h
namespace BasicMath
{
    // function add() is part of namespace BasicMath
    int add(int x, int y)
    {
        return x + y;
    }
}

// subtract.h
namespace BasicMath
{
    // function subtract() is also part of namespace BasicMath
    int subtract(int x, int y)
    {
        return x - y;
    }
}

// main.cpp
#include "add.h" // import BasicMath::add()
#include "subtract.h" // import BasicMath::subtract()

int main()
{
    std::cout << BasicMath::add(4, 3) << '\n';
    std::cout << BasicMath::subtract(4, 3) << '\n';

    return 0;
}
```

nested namespace:

```cpp
#include <iostream>

namespace Foo
{
    namespace Goo // Goo is a namespace inside the Foo namespace
    {
        const int g_x = 5;
    }
}

int main()
{
    std::cout << Foo::Goo::g_x;
    return 0;
}

// in c++ 17
#include <iostream>

namespace Foo::Goo // Goo is a namespace inside the Foo namespace (C++17 style)
{
    const int g_x = 5;
}

int main()
{
    std::cout << Foo::Goo::g_x;
    return 0;
}
```

Namespace aliases:

```cpp
namespace Boo = Foo::Goo; // Boo now refers to Foo::Goo

int main()
{
  std::cout << Boo::g_x; // This is really Foo::Goo::g_x
  return 0;
}
```

## 4.3c `using` statements

#### The using declaration

```cpp
#include <iostream>

int main()
{
   using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout
   cout << "Hello world!"; // so no std:: prefix is needed here!
   return 0;
}
```

#### The using directive

```cpp
#include <iostream>

int main()
{
   using namespace std; // this using directive tells the compiler that we're using everything in the std namespace!
   cout << "Hello world!"; // so no std:: prefix is needed here!
   return 0;
}
```

The using directive `using namespace std;` tells the compiler that we want to use everything in the `std` namespace, so if the compiler finds a name it doesn’t recognize, it will check the `std` namespace.

#### ambiguous definition

```cpp
#include <iostream> // imports the declaration of std::cout

int cout() // declares our own "cout" function
{
    return 5;
}

int main()
{
    using namespace std; // makes std::cout accessible as "cout"
    cout << "Hello, world!"; // uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
```

we could fix this by explicitly call with `::`, or __using declaration__:

```cpp
using std::cout; // tell the compiler that cout means std::cout
cout << "Hello, world!"; // so this means std::cout
```

The using declaration `using std::cout;` tells the compiler that we’re going to be using the object `cout` from the `std` namespace. So whenever it sees `cout`, it will assume that we mean `std::cout`.

__If there’s a naming conflict between `std::cout` and some other use of `cout`, `std::cout` will be preferred__.

> Rule: Avoid `using` statements outside of a function (in the global scope).
>
> Suggestion: We recommend you avoid `using directives` entirely.

### Cancelling or replacing a using statement

Once a using statement has been declared, __there’s no way to cancel or replace it with a different using statement within the scope in which it was declared__.

```cpp
int main()
{
    using namespace Foo;

    // there's no way to cancel the "using namespace Foo" here!
    // there's also no way to replace "using namespace Foo" with a different using statement

    return 0;
} // using namespace Foo ends here
```

can only intentionally limit the scope of the using statement from:

```cpp
int main()
{
    {
        using namespace Foo;
        // calls to Foo:: stuff here
    } // using namespace Foo expires

    {
        using namespace Goo;
        // calls to Goo:: stuff here
    } // using namespace Goo expires

    return 0;
}
```

## 4.4 Type Conversion

1. implicit type conversion - type coercion
2. explicit type conversion - type casting

#### C-style casts

via the `()` operator:

```cpp
int i1 = 10;
int i2 = 4;
float f = (float)i1 / i2;
```

Because __C-style casts are not checked by the compiler at compile time__, C-style casts can be inherently misused, because they will let you do things that may not make sense, such as getting rid of a const or changing a data type without changing the underlying representation (leading to garbage results).

> Rule: Avoid C-style casts

#### static_cast

```cpp
char c = 'a';
std::cout << static_cast<int>(c) << std::endl; // prints 97, not 'a'

int i1 = 10;
int i2 = 4;
float f = static_cast<float>(i1) / i2;
```

The main advantage of static_cast is that it provides compile-time type checking.

## 4.4b `std::string`

```cpp
#include <string>
#include <iostream>

int main()
{
    std::cout << "Enter your full name: ";
    std::string name;
    std::cin >> name; // this won't work as expected since std::cin breaks on whitespace

    std::cout << "Enter your age: ";
    std::string age;
    std::cin >> age;

    std::cout << "Your name is " << name << " and your age is " << age;
}

// output
// Enter your full name: John Doe
// Enter your age: Your name is John and your age is Doe
```

> operator ``>>`` only returns characters up to the first whitespace it encounters. Any other characters are left inside `cin`, waiting for the next extraction.

Use `std::getline()` to input text

```cpp
std::cout << "Enter your full name: ";
std::string name;
std::getline(std::cin, name); // read a full line of text into name

std::cout << "Enter your age: ";
std::string age;
std::getline(std::cin, age); // read a full line of text into age

std::cout << "Your name is " << name << " and your age is " << age;
```

Mixing inputs with both `std::cin` and `std::getline` may cause some unexpected behavior.

`cin` actually gets the string "2\n" with new line char. It then extracts the `2` to variable `choice`, leaving the newline stuck in the input stream. Then, __when `std::getline()` goes to read the name, it sees ``\n` is already in the stream__, and figures we must have entered an empty string!

> A good rule of thumb is that after reading a value with `std::cin`, remove the newline from the stream.

```cpp
int main()
{
  std::cout << "Pick 1 or 2: ";
  int choice { 0 };
  std::cin >> choice;

  std::cin.ignore(32767, '\n'); // ignore up to 32767 characters until a \n is removed

  std::cout << "Now enter your name: ";
  std::string name;
  std::getline(std::cin, name);

  std::cout << "Hello, " << name << ", you picked " << choice << '\n';

  return 0;
}

// instead of cin.ignore, use better one
#include <limits>
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore unlimited characters until a \n is removed
```

## 4.5 Enumeration

An enumerated type (also called an enumeration) is a data type where every possible value is defined as a symbolic constant (called an enumerator).

```cpp
// Define a new enumeration named Color
enum Color
{
    // Here are the enumerators
    // These define all the possible values this type can hold
    // Each enumerator is separated by a comma, not a semicolon
    COLOR_BLACK,
    COLOR_RED,
    COLOR_BLUE,
    COLOR_GREEN,
    COLOR_WHITE,
    COLOR_CYAN,
    COLOR_YELLOW,
    COLOR_MAGENTA, // see note about trailing comma on the last enumerator below
}; // however the enum itself must end with a semicolon

// Define a few variables of enumerated type Color
Color paint = COLOR_WHITE;
Color house(COLOR_BLUE);
Color apple { COLOR_RED };
```

__Defining an enumeration (or any user-defined data type) does not allocate any memory__. When a variable of the enumerated type is defined (such as variable paint in the example above), memory is allocated for that variable at that time.

#### Enumerator values

__Each enumerator is automatically assigned an integer value based on its position in the enumeration list__, value default start from 0. It can be assigned.

```cpp
Color paint(COLOR_WHITE);
std::cout << paint;

// output
// 4
```
