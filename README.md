# Notes for Learn CPP

learn and gain from the source:

https://www.learncpp.com/cpp-tutorial

## 0.5 Compile & Run

> it translates your C++ source code into a machine language file called an object file. Object files are typically named name.o or name.obj, where name is the same name as the .cpp file it was produced from.
>
> So compile output `.o` or `.obj` machine code files
>
> After the compiler creates one or more object files, then another program called the linker kicks in. The job of the linker is three fold:
>
> 1. to take all the object files generated by the compiler and combine them into a single executable program.
>
> 2. the linker also is capable of linking library files. A library file is a collection of precompiled code that has been “packaged up” for reuse in other programs. ex: C++ standard library
>
> 3. the linker __makes sure all cross-file dependencies are resolved properly__. For example, if you define something in one .cpp file, and then use it in another .cpp file, the linker connects the two together. If the linker is unable to connect a reference to a thing with the definition of that thing, you’ll get a linker error, and the linking process will abort.
>
> For complex projects, some development environments use a __makefile__, which is a file that describes how to build a program (e.g. which files to compile and link, or otherwise process in various ways)

After `compile -> link` then the `.exe` or `a.out` is pop

## 0.x Mac Cmds

```sh
clang++ -std=c++11 -stdlib=libc++ 05.cpp
```

## 1.3 l-value vs r-value

> In C++, variables are a type of __l-value__. An l-value is a value that has a persistent address (in memory).
>
> Since all variables have addresses, all variables are l-values. The name l-value came about because l-values are the only values that can be on the left side of an assignment statement. __When we do an assignment, the left hand side of the assignment operator must be an l-value__. Consequently, a statement like 5 = 6; will cause a compile error, because 5 is not an l-value. The value of 5 has no memory, and thus nothing can be assigned to it. 5 means 5, and its value can not be reassigned. When an l-value has a value assigned to it, the current value at that memory address is overwritten.
>
> The opposite of l-values are __r-values__. An r-value refers to values that are not associated with a persistent memory address. Examples of r-values are single numbers (such as 5, which evaluates to 5) and expressions (such as 2 + x, which evaluates to the value of variable x plus 2). r-values are generally temporary in nature and are discarded at the end of the statement in which they occur


```cpp
int y;      // define y as an integer variable
y = 4;      // r-value 4 evaluates to 4, which is then assigned to l-value y
y = 2 + 5;  // r-value 2 + r-value 5 evaluates to r-value 7, which is then assigned to l-value y

int x;      // define x as an integer variable
x = y;      // l-value y evaluates to 7 (from before), which is then assigned to l-value x.
x = x;      // l-value x evaluates to 7, which is then assigned to l-value x (useless!)
x = x + 1;  // l-value x + r-value 1 evaluate to r-value 8, which is then assigned to l-value x.
```

## 1.3a cin, cout, endl

```cpp
#include <iostream>

std::cout << "Hello";
int x;
std::cin >> x;
std::count << "world" << x << std:endl;
```

## 1.4 caller vs callee

> The function initiating the function call is called the __caller__, and the function being called is the __callee__ or __called__ function.

```cpp
#include <iostream> // for std::cout and std::endl

// Definition of function doPrint()
// doPrint() is the __called__ or __callee__ function
void doPrint()
{
    std::cout << "In doPrint()" << std::endl;
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()" << std::endl;
    doPrint();
    // Interrupt main() by making a function call to doPrint().
    // main() is the caller.
    std::cout << "Ending main()" << std::endl;

    return 0;
}
```

## 1.41 why main have return type `int`

> You now have the conceptual tools to understand how the `main()` function actually works. When the program is executed, the operating system makes a function call to `main()`.
>
> Execution then jumps to the top of `main`. The statements in main are executed sequentially. Finally, __`main` returns an integer value (usually 0) back to the operating system__. This is why main is defined as `int main()`.
>
> Why return a value back to the operating system?
>
> __This value is called a status code, and it tells the operating system (and any other programs that called yours) whether your program executed successfully or not__.

__By consensus, a return value of 0 means success, and a positive return value means failure__.

```sh
» ls -al
total 56
drwxr-xr-x   5 james_yang  staff    170 Dec  1 11:24 .
drwxr-xr-x  58 james_yang  staff   1972 Dec  1 10:50 ..
-rw-r--r--   1 james_yang  staff    167 Dec  1 11:15 05.cpp
-rw-r--r--@  1 james_yang  staff   4713 Dec  1 11:24 NOTES.md
-rwxr-xr-x   1 james_yang  staff  16120 Dec  1 11:13 a.out
» echo $?
0
# ^ exit status 0 means success
```

if a function has a non-void return type, it must return a value of that type (using a return statement). The only exception to this rule is for function `main()`, __which will assume a return value of 0 if one is not explicitly provided__.


## 1.42 No Nested Function

Functions can not be defined inside other functions (called nesting) in C++.

## 1.43 quiz

```cpp
#include <iostream>
void printA()
{
    std::cout << "A" << std::endl;
}

int main()
{
    std::cout << printA() << std::endl;

    return 0;
}
```

^ does not compile. __Function `printA()` returns `void`, which main tries to send to `std::cout`. This will produce a compile error__.


## 1.4c key word

https://www.learncpp.com/cpp-tutorial/14c-keywords-and-naming-identifiers/

## 1.5a operand and operator

> __Literals, variables, and function calls__ that return values are all known as __operands. Operands supply the data__ that the expression works with.
>
> __Operators tell the expression how to combine one or more operands to produce a new result__. For example, in the expression `3 + 4`, the `+` is the plus operator

Operators come in three types:

- Unary operators act on one operand. An example of a unary operator is the `-` operator. In the expression `-5`, the `-` operator is only being applied to one operand `5` to produce a new value `-5`.

- Binary operators act on two operands (known as left and right). An example of a binary operator is the + operator. In the expression `3 + 4`, the `+` operator is working with a left operand `3` and a right operand `4` to produce a new value `7`.

- Ternary operators act on three operands. There is only one of these in C++, which we’ll cover later.

## 1.7 Forward declarations and definitions

```cpp
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl;
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

then output:

```sh
add.cpp(5) : error C3861: 'add': identifier not found
add.cpp(9) : error C2365: 'add' : redefinition; previous definition was 'formerly unknown identifier'
```

> When the compiler reaches the function call to `add()` on line 5 of `main()`, it doesn’t know what add is, because we haven’t defined `add()` until line 9! That produces the first error __identifier not found__.

Reorder is not good idea when the orders are matter.

A __forward declaration__ allows us to tell the compiler about the existence of an identifier before actually defining the identifier.

```cpp
#include <iostream>

int add(int x, int y);
// forward declaration of add() (using a function prototype)

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << std::endl; // this works because we forward declared add() above
    return 0;
}

int add(int x, int y) // even though the body of add() isn't defined until here
{
    return x + y;
}
```

what happens if we forward declare a function but do not define it?

> it depends.
>
> If a forward declaration is made, but the function is never called, the program will compile and run fine.
>
> However, if a forward declaration is made, the function is called, but the program never defines the function, the program will compile okay, __but the linker will complain that it can’t resolve the function call__.

```cpp
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

## 1.71 Declarations vs. definitions

> A __definition__ actually implements or instantiates (causes memory to be allocated for) the identifier.
>
> __A definition is needed to satisfy the linker. If you use an identifier without providing a definition, the linker will error__.
>
> A __declaration__ is a statement that tells the compiler about the existence of an identifier (variable or function name) and its type. Here are some examples of declarations:
>
> __A declaration is all that is needed to satisfy the compiler. If you use an identifier without providing a declaration, the compiler will error__.

## 1.8a Naming Confliction

C++ requires that all identifiers __variable and/or function names__ be non-ambiguous.

> Rule: When you use an identifier in a namespace, you always have to identify the namespace along with the identifier
>
> The most straightforward way to tell the compiler that cout lives in the std namespace is by using the `std::` prefix. For example:

```cpp
std::cout << "Hello world!";
```

So the same name identifier would not conflict.

## 1.9 Header File

> __Header guards__ prevent a given header file from being #included more than once in the same file.

```cpp
// add.h
// This is start of the header guard.  
// ADD_H can be any unique name.  
// By convention, we use the name of the header file.
#ifndef ADD_H
#define ADD_H

// This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!

// This is the end of the header guard
#endif
```
> Why doesn’t `iostream` have a `.h` extension?

The answer is, because `iostream.h` is a different header file than `iostream` is! To explain requires a very short history lesson.

The original version of cout and cin lived in iostream.h. When the language was standardized by the ANSI committee, they decided to move all of the functions in the runtime library into the `std` namespace (which is generally a good idea). However, this presented a problem: __if they moved all the functions into the std namespace, none of the old programs would work any more!__

To try to get around this issue and provide backwards compatibility for older programs, a new set of header files was introduced that use the same names __but lack the `.h` extension__. These new header files have all their functionality inside the std namespace.

This way, older programs that include `#include <iostream.h>` do not need to be rewritten, and newer programs can `#include <iostream>`.

#### Including header files from other directories

One (bad) way to do this is to include a relative path to the header file you want to include as part of the `#include` line. For example:

```cpp
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

The downside of this approach is that it requires you to reflect your directory structure in your code.

Using g++, you can use the `-I` option to specify __an alternate include directory__.

```cpp
g++ -o main -I /source/includes main.cpp
```

#### Can I put function or variable definitions in a header file?

> You shouldn’t, as it may cause linker errors. We’ll explain why in the upcoming lesson on header guards.


## 1.10 Preprocesssor

When the preprocessor runs, it simply scans through each code file from top to bottom, looking for directives. __Directives are specific instructions that start with a `#` symbol and end with a newline (NOT a semicolon)__.

The preprocessor is not smart -- it does not understand C++ syntax; rather, it simply manipulates text before the compiler runs. The output of the preprocessor is then sent to the compiler.

> __Note that the preprocessor does not modify the original code files in any way rather, all text changes made by the preprocessor happen temporarily in-memory__.

The `#define` directive can be used to create a macro. __A macro is a rule that defines how an input sequence (e.g. an identifier) is converted into a replacement output sequence (e.g. some text)__.

There are two basic types of macros: `object-like macros`, and `function-like macros`.


Function-like macros act like functions, and serve a similar purpose. We will not discuss them, __because their use is generally considered dangerous, and almost anything they can do can be done by an (inline) function__.

Object-like macros can be defined in one of two ways:

```cpp
#define identifier
#define identifier substitution_text
```

#### Object-like macros with substitution text

```cpp
#define MY_FAVORITE_NUMBER 9
std::cout << "My favorite number is: " << MY_FAVORITE_NUMBER << std::endl;

// preproceed to
std::cout << "My favorite number is: " << 9 << std::endl;
```

__We discuss this case (and why you shouldn’t use it) in more detail in section 2.9__

#### Object-like macros without substitution text

```cpp
#define USE_YEN
```

any further occurrence of the identifier is removed and replaced by nothing! This might seem pretty useless, and it is for doing text substitution.

__Unlike object-like macros with substitution text, macros of this form are generally considered acceptable to use.__

#### Conditional compilation

```cpp
// define as nothing
#define PRINT_JOE

#ifdef PRINT_JOE
std::cout << "Joe" << std::endl;
#endif

#ifdef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif

#ifndef PRINT_BOB
std::cout << "Bob" << std::endl;
#endif
```

> Since we defined `PRINT_JOE` to be __nothing__, how come the preprocessor didn’t replace `PRINT_JOE` in `#ifdef PRINT_JOE` with __nothing__?

__Macros only cause text substitution for normal code. Other preprocessor commands are ignored__.

```cpp
#define FOO 9 // Here's a macro substitution

// This FOO does not get replaced
// because it’s part of preprocessor directive
#ifdef FOO
    std::cout << FOO;
    // This FOO gets replaced with 9
    // because it's part of the normal code
#endif
```

#### The scope of defines

Directives are resolved before compilation, __from top to bottom on a file-by-file basis__. __Once the preprocessor has finished, all directives from that file are discarded__.

```cpp
// function.cpp
#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!";
#endif
#ifndef PRINT
    std::cout << "Not printing!";
#endif
}

// main.cpp
void doSomething(); // forward declaration for function doSomething()

int main()
{
#define PRINT

    doSomething();

    return 0;
}

// output: Not printing!
```

## 1.10a Header guards

```cpp
//math.h:
int getSquareSides()
{
    return 4;
}

//geometry.h:
#include "math.h"


//main.cpp:
#include "math.h"
#include "geometry.h"

int main()
{
    return 0;
}
```

`main.cpp #includes math.h`, which copies the definition for function `getSquareSides` into main.cpp.

Then `main.cpp #includes geometry.h`, which `#includes math.h` itself. This copies the definition for function `getSquareSides` into `geometry.h`, which then gets copied into `main.cpp`.

Thus, after resolving all of the `#includes` by preprocessor, `main.cpp` ends up looking like this:

Duplicate definitions and a compile error

```cpp
int getSquareSides()  // from math.h
{
    return 4;
}

int getSquareSides() // from geometry.h
{
    return 4;
}

int main()
{
    return 0;
}
```

#### Header Guards

Header guards are conditional compilation directives:

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations and definitions here

#endif
```

typically the name of the header file with a `_H` appended to it is used. For example, `math.h` would have the header guard

```cpp
// math.h
#ifndef MATH_H
#define MATH_H

int getSquareSides()
{
    return 4;
}

#endif
```

Then previous example can be resolved by:

```cpp
// math.cpp
#ifndef MATH_H
#define MATH_H

int getSquareSides()
{
    return 4;
}

#endif

// geometry.h
#ifndef GEOMETRY_H
#define GEOMETRY_H

#include "math.h"

#endif

// main.cpp
#include "math.h"
#include "geometry.h"

int main()
{
    return 0;
}
```

#### Can’t we just avoid definitions in header files?

There are quite a few cases we’ll show you in the future where it’s desirable to put definitions in a header file, for example, when it comes to __user-defined types (such as structs and classes)__.

Header guards __do not prevent a given header file from being included (once) into different code files__. This can cause unexpected problems. Consider:


```cpp
// square.h:
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif

// square.cpp
#include "square.h"  // square.h is included once here

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}

// main.cpp
#include <iostream>
#include "square.h" // square.h is also included once here

int main()
{
    std::cout << "a square has " << getSquareSides() << " sides" << std::endl;
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << std::endl;

    return 0;
}
```

When `square.h` is included from `square.cpp`, `SQUARE_H` is __defined until the end of `square.cpp`__.

This define prevents `square.h` from being included into `square.cpp` a second time (which is the point of header guards).

__However, once `square.cpp` is finished, `SQUARE_H` is no longer considered defined__. (preprocessor is file-by-file based text subtitution)

__This means that when the preprocessor runs on `main.cpp`, `SQUARE_H` is not initially defined in `main.cpp`__.

> The end result is that both `square.cpp` and `main.cpp` get a copy of the definition of `getSquareSides()`.

This program will compile, but the linker will complain about your program having __multiple definitions for identifier `getSquareSides`__!

The workaround solution is to change that definition as forward declaration in root base header file, __so let the later included header file implement it__.

```cpp
// square.h:
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides(); // forward declaration for getSquareSides
int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif

// square.cpp:
// It would be okay to #include square.h here if needed
// This program doesn't need to.

int getSquareSides() // actual definition for getSquareSides
{
    return 4;
}

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}

// main.cpp
#include <iostream>
#include "square.h" // square.h is also included once here

int main()
{
    std::cout << "a square has " << getSquareSides() << "sides" << std::endl;
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << std::endl;

    return 0;
}
```

## 2.1 Variable

#### Initialization

1. copy initialization

    ```cpp
    int nValue = 5; // copy initialization
    ```

2. direct initialization by using parenthesis

    ```cpp
    int nValue(5); // direct initialization
    ```

    Consequently, we recommend using direct initialization over copy initialization.

3. Uniform initialization in C++11

    ```cpp
    int value{5}; // uniform initialization

    int value{}; // default initialization to 0
    ```

    Initializing a variable with an empty brace indicates default initialization. __Default initialization initializes the variable to zero (or empty, if that’s more appropriate for a given type)__.

    Uniform initialization has the added benefit of __disallowing “narrowing” type conversions__. This means that if you try to use uniform initialization to initialize a variable with a value it can not safely hold, the compiler will throw an warning or error. For example:

    ```cpp
    int value{4.5}; // error: an integer variable can not hold a non-integer value
    ```

    If you’re using a C++11 compatible compiler, __favor uniform initialization__.

#### Variable assignment

When a variable is given a value after it has been defined, it is called a __copy assignment__ (or assignment for short).

```cpp
int nValue;
nValue = 5; // copy assignment
```

C++ does not provide any built-in way to do a direct or uniform assignment.

#### Uninitialized variables

In C++, a fundamental variable that is uninitialized will have a garbage value until you assign a valid one.

Rule: __Always initialize your fundamental variables, or assign a value to them as soon as possible after defining them__.

#### Defining multiple variables

It is possible to define multiple variables of the same type in a single statement by separating the names with a comma.

```cpp
int a, b;
int a = 5, b = 6;
int c(7), d(8);
int e{9}, f{10};

int a, b = 5; // wrong (a is uninitialized!)

int a= 5, b= 5; // correct

int a, b(5);
int c, d{5};
// better help if using uniform/direct initialization
```

In the top statement, variable `a` will __be left uninitialized, and the compiler may or may not complain__. But may leads problem.

#### Where to define variables

Older C compilers forced users to define all of the variables in a function at the top of the function:

```cpp
int main()
{
    // all variable up top
    int x;
    int y;

    // then code
    std::cout << "Enter a number: ";
    std::cin >> x;

    std::cout << "Enter another number: ";
    std::cin >> y;

    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```

This style is now obsolete. C++ compilers do not require all variables to be defined at the top of a function.

__The proper C++ style is to define variables as close to the first use of that variable as you reasonably can__:

```cpp
int main()
{
    std::cout << "Enter a number: ";
    int x; // we need x on the next line, so we'll declare it here, as close to its first use as we reasonably can.
    std::cin >> x; // first use of x

    std::cout << "Enter another number: ";
    int y; // we don't need y until now, so it gets declared here
    std::cin >> y; // first use of y

    std::cout << "The sum is: " << x + y << std::endl;
    return 0;
}
```

__Rule: Define variables as close to their first use as you reasonably can__.

## 2.2 Void

In C, as a way to indicate that a function does not take any parameters:

```cpp
int getValue(void)
// void here means no parameters
// is necessary for c program
{
    int x;
    std::cin >> x;
    return x;
}
```

The explicit use of keyword void to mean __no parameters__ is a holdover from C, and is not required in C++.

The following code is equivalent, and preferred in C++:

```cpp
int getValue()
// empty function parameters is an implicit void
{
    int x;
    std::cin >> x;
    return x;
}
```

## 2.4 Sizeof and Integer

0. `char` is to be minimum 1 byte.

1. `short` is ensure to be minimum 2 bytes, which is 16 bits.

2. `int` is ensure to be minimum 2 bytes, but usually 4 bytes on modern architectures.

3. `long` is surprise to minimum 4 bytes, rather than java's 8 bytes.

4. `long long` in C99/C++11 type is 8 bytes.

#### What is size_t?

`sizeof` (and many functions that return a size or length value) return a value of type `size_t`.

`size_t` is an __unsigned, integral value that is typically used to represent the size or length of objects__.

Amusingly, we can use `sizeof` (__which returns a value of type `size_t`__) to ask for the size of `size_t` itself:

```cpp
#include <iostream>
int main()
{
  std::cout << sizeof(size_t);

  return 0;
}
```

Compiled as a 32-bit (4 byte) console app on the author’s system, this prints `4`.

That is, for 32-bit applications, `size_t` will typically be a 32 bit unsigned integer, and for a 64-bit application, `size_t` will typically be a 64-bit unsigned integer.

__`size_t` is defined to be big enough to hold the size of the largest object creatable on your system (in bytes)__.

By definition, any object larger than the largest value `size_t` can hold is __considered ill-formed (and will cause a compile error), as the `sizeof` operator would not be able to return the size without overflow__.

## 2.4a Fixed-width integers and the unsigned controversy

The short, non-technical answer is that this goes back to C, when performance was of utmost concern. __C opted to intentionally leave the size of an integer open so that the compiler implementers could pick a size for `int` that performs best on the target computer architecture__.

#### Fixed-width integers

To help with cross-platform portability, C99 defined a set of __fixed-width__ integers (in the `stdint.h` header) that are guaranteed to have the same size on any architecture.

```cpp
int8_t	     1 byte signed
uint8_t	     1 byte unsigned
int16_t	     2 byte signed
uint16_t     2 byte unsigned
int32_t	     4 byte signed
uint32_t     4 byte unsigned
int64_t	     8 byte signed
uint64_t     8 byte unsigned
```

C++ officially adopted these fixed-width integers as part of C++11.

They can be accessed by including the `cstdint` header, where they are defined inside the `std` namespace. Here’s an example:

```cpp
#include <iostream>
#include <cstdint>

int main()
{
    std::int16_t i(5); // direct initialization
    std::cout << i;
    return 0;
}
```

#### Warning: `int8_t` and `uint8_t` may or may not behave like `char`

```cpp
#include <cstdint>
#include <iostream>

int main()
{
    int8_t myint = 65;
    std::cout << myint;

    return 0;
}
```

Most compilers define and treat `int8_t` and `uint8_t` identically to types `signed char` and `unsigned char` respectively, but this is not required.

On most systems, this program will print `A` (treating `myint` as a `char`). __However, on some systems, this may print `65` as expected__.

> For simplicity, __it’s best to avoid `int8_t` and `uint8_t` altogether (use `int16_t` or `uint16_t` instead)__.
>
> However, if you do use `int8_t` or `uint8_t`, __you should be careful of any function that would interpret `int8_t` or `uint8_t` as a `char` instead of an integer (this includes `std::cout` and `std::cin`)__.

__Rule: Avoid `int8_t` and `uint8_t`. If you do use them, note that they are often treated like chars__.

#### The downsides of fixed-width integers

Fixed-width integers may not be supported on architectures where those types can’t be represented. They may also be less performant than the built-in types on some architectures.

To help address the above downsides, C++11 also defines two alternative sets of fixed-width integers.

#### Fast and least

The fast type (`int_fast#_t`) __gives you an integer that’s the fastest type with a width of at least # bits (where # = 8, 16, 32, or 64)__. For example, `int_fast32_t` will give you the fastest integer type that’s at least 32 bits.

The least type (`int_least#_t`) __gives you the smallest integer type with a width of at least # bits (where # = 8, 16, 32, or 64)__. For example, `int_least32_t` will give you the smallest integer type that’s at least 32 bits.

#### The controversy over unsigned numbers

Many developers (and some large development houses, such as Google) believe that developers should generally avoid unsigned integers.

__This is largely because unexpected behavior can result when you mix signed and unsigned integers__.

```cpp
void doSomething(unsigned int x)
{
    // Run some code x times
}

int main()
{
    doSomething(-1);
}
// -1 gets converted to some large number (probably 4294967295)
```

## 2.5 floating point

`long double` minimum size to 8 bytes, typically can be 8, 12, or 16 bytes.

#### NaN and Inf

The first is Inf, which represents infinity. `Inf` can be positive or negative. The second is `NaN`, which stands for “Not a Number”.

```cpp
include <iostream>

int main()
{
    double zero = 0.0;
    double posinf = 5.0 / zero; // positive infinity
    std::cout << posinf << std::endl;

    double neginf = -5.0 / zero; // negative infinity
    std::cout << neginf << std::endl;

    double nan = zero / zero; // not a number (mathematically invalid)
    std::cout << nan << std::endl;

    return 0;
}
// 1.#INF
// -1.#INF
// 1.#IND
```

`INF` stands for infinity, and `IND` stands for indeterminate. Note that the results of printing `Inf` and `NaN` are platform specific, so your results may vary.

## 2.9 Const, constexpr, and symbolic constants

#### Const

run-time constant use `const`:

```cpp
std::cout << "Enter your age: ";
int age;
std::cin >> age;

const int usersAge (age); // usersAge can not be changed

// Const is used most often with function parameters:
void printInteger(const int myValue)
{
    std::cout << myValue;
}
```

`usersAge` relies on user input (which can only be given at runtime) and `myValue` depends on the value passed into the function (which is only known at runtime).

Making a function parameter const does two things.

1. it tells the person calling the function that the function will not change the value of myValue.
2. it ensures that the function doesn’t change the value of `myValue` (if `myValue` is a reference).

#### Constexpr

C++ actually has two different kinds of constants.

Because a `const` value could be either runtime or compile-time, the compiler has to keep track of which kind of constant it is.

To help provide more specificity, C++11 introduced new keyword `constexpr`, __which ensures that the constant must be a compile-time constant__:

```cpp
constexpr double gravity (9.8); // ok, the value of 9.8 can be resolved at compile-time
constexpr int sum = 4 + 5; // ok, the value of 4 + 5 can be resolved at compile-time

std::cout << "Enter your age: ";
int age;
std::cin >> age;
constexpr int myAge = age; // not okay, age can not be resolved at compile-time
```

#### Using symbolic constants throughout a program

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

// define your own namespace to hold constants
namespace constants
{
    constexpr double pi(3.14159);
    constexpr double avogadro(6.0221413e23);
    constexpr double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
    // ... other related constants
}
#endif

// main.cpp
#include "constants.h"
double circumference = 2 * radius * constants::pi;
```

## 3.8a Bit flags and bit masks

#### Bit flags

However, in some storage-intensive cases, it can be useful to `pack` 8 individual boolean values into a single byte for storage efficiency purposes.

This is done by using the bitwise operators to set, clear, and query individual bits in a byte, __treating each as a separate boolean value__. These individual bits are called bit flags.

#### Defining bit flags in C++14

Because C++14 supports binary literals, this is easiest in C++14:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 0b0000'0001; // represents bit 0
const unsigned char option1 = 0b0000'0010; // represents bit 1
const unsigned char option2 = 0b0000'0100; // represents bit 2
const unsigned char option3 = 0b0000'1000; // represents bit 3
const unsigned char option4 = 0b0001'0000; // represents bit 4
const unsigned char option5 = 0b0010'0000; // represents bit 5
const unsigned char option6 = 0b0100'0000; // represents bit 6
const unsigned char option7 = 0b1000'0000; // represents bit 7
```

#### Defining bit flags in C++11 or earlier

use hex:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 0x1; // hex for 0000 0001
const unsigned char option1 = 0x2; // hex for 0000 0010
const unsigned char option2 = 0x4; // hex for 0000 0100
const unsigned char option3 = 0x8; // hex for 0000 1000
const unsigned char option4 = 0x10; // hex for 0001 0000
const unsigned char option5 = 0x20; // hex for 0010 0000
const unsigned char option6 = 0x40; // hex for 0100 0000
const unsigned char option7 = 0x80; // hex for 1000 0000
```

or left-shift operator:

```cpp
// Define 8 separate bit flags (these can represent whatever you want)
const unsigned char option0 = 1 << 0; // 0000 0001
const unsigned char option1 = 1 << 1; // 0000 0010
const unsigned char option2 = 1 << 2; // 0000 0100
const unsigned char option3 = 1 << 3; // 0000 1000
const unsigned char option4 = 1 << 4; // 0001 0000
const unsigned char option5 = 1 << 5; // 0010 0000
const unsigned char option6 = 1 << 6; // 0100 0000
const unsigned char option7 = 1 << 7; // 1000 0000
```

#### Turning individual bits on

To set a bit (turn on), we use bitwise OR equals (operator |=):

```cpp
unsigned char myflags = 0; // all bits turned off to start

myflags |= option4;
// turn option 4 on
myflags |= (option4 | option5);
// turn options 4 and 5 on at the same time

myflags &= ~option4;
// turn option 4 off
myflags &= ~(option4 | option5);
// turn options 4 and 5 off at the same time

myflags ^= option4;
// flip option4 from on to off, or vice versa
myflags ^= (option4 | option5);
// flip options 4 and 5 at the same time

// Determining if a bit is on or off
if (myflags & option4)
    std::cout << "myflags has option 4 set";
if (!(myflags & option5))
    std::cout << "myflags does not have option 5 set";
```

#### An introduction to std::bitset

```cpp
#include <bitset>

std::bitset<8> bits; // we need 8 bits

// initialized with an initial set of values:
std::bitset<8> bits(option1 | option2);
// start with option 1 and 2 turned on

std::bitset<8> morebits(0x3);
// start with bit pattern 0000 0011
```

`std::bitset` provides 4 key functions: `test`, `flip`, `set`, `reset`:

```cpp
#include <bitset>
#include <iostream>

// Note that with std::bitset, our options correspond to bit indices, not bit patterns
const int option0 = 0;
const int option1 = 1;
const int option2 = 2;
const int option3 = 3;
const int option4 = 4;
const int option5 = 5;
const int option6 = 6;
const int option7 = 7;

int main()
{
    std::bitset<8> bits(0x2); // we need 8 bits, start with bit pattern 0000 0010
    bits.set(option4); // set bit 4 to 1 (now we have 0001 0010)
    bits.flip(option5); // flip bit 5 (now we have 0011 0010)
    bits.reset(option5); // set bit 5 back to 0 (now we have 0001 0010)

    std::cout << "Bit 4 has value: " << bits.test(option4) << '\n';
    std::cout << "Bit 5 has value: " << bits.test(option5) << '\n';
    std::cout << "All the bits: " << bits << '\n';

    return 0;
}
```

#### bit mask

When we __bundle individual bits together for the purpose of modifying them as a group__, this is called a bit mask.

```cpp
#include <iostream>

int main()
{
    const unsigned int lowMask = 0xF; // bit mask to keep low 4 bits (hex for 0000 0000 0000 1111)

    std::cout << "Enter an integer: ";
    int num;
    std::cin >> num;

    num &= lowMask; // remove the high bits to leave only the low bits

    std::cout << "The 4 low bits have value: " << num << '\n';

    return 0;
}

// Enter an integer: 151
// The 4 low bits have value: 7
```

Example: RGBA example:

RGBA need 8-bit unsigned integer each hue. so a 32-bit RGBA value represent it.

```cpp
#include <iostream>
int main()
{
    const unsigned int redBits = 0xFF000000;
    const unsigned int greenBits = 0x00FF0000;
    const unsigned int blueBits = 0x0000FF00;
    const unsigned int alphaBits = 0x000000FF;

    std::cout << "Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): ";
    unsigned int pixel;
    std::cin >> std::hex >> pixel; // std::hex allows us to read in a hex value

    // use bitwise AND to isolate red pixels, then right shift the value into the range 0-255
    unsigned char red = (pixel & redBits) >> 24;
    unsigned char green = (pixel & greenBits) >> 16;
    unsigned char blue = (pixel & blueBits) >> 8;
    unsigned char alpha = pixel & alphaBits;

    std::cout << "Your color contains:\n";
    std::cout << static_cast<int>(red) << " of 255 red\n";
    std::cout << static_cast<int>(green) << " of 255 green\n";
    std::cout << static_cast<int>(blue) << " of 255 blue\n";
    std::cout << static_cast<int>(alpha) << " of 255 alpha\n";

    return 0;
}

//Enter a 32-bit RGBA color value in hexadecimal (e.g. FF7F3300): FF7F3300
//Your color contains:
//255 of 255 red
//127 of 255 green
//51 of 255 blue
//0 of 255 alpha
```

## 4.1a Local variables, scope, and duration

#### block

A block of statements, also called a compound statement, is a group of statements that is treated by the compiler as if it were a single statement. Blocks begin with a `{` symbol, end with a `}` symbol.

__blocks__ allow multiple statements to be used wherever a single statement can normally be used. They are extremely useful when you need a set of statements to execute together.

#### scope and duration

A variable’s `scope` determines where a variable is accessible. __A variable’s `duration` determines where it is created and destroyed__. The two concepts are often linked

Local variables have __automatic duration__, which means they are created (and initialized, if relevant) at the point of definition, and destroyed when the block they are defined in is exited.

Local variables have __block scope (also called local scope)__, which means they enter scope at the point of declaration __and go out of scope at the end of the block that they are defined in__.

```cpp
int main() // outer block
{
    int n(5); // n created and initialized here

    { // begin nested block
        double d(4.0); // d created and initialized here
    } // d goes out of scope and is destroyed here

    // d can not be used here because it was already destroyed!

    return 0;
} // n goes out of scope and is destroyed here
```

Variables __defined inside a block can only be seen within that block__.

#### Shadowing

Note that a variable inside a nested block can have the same name as a variable inside an outer block. When this happens, the nested variable “hides” the outer variable. This is called __name hiding__ or __shadowing__.

> Rule: Avoid using nested variables with the same names as variables in an outer block.
>
> Variables should be defined in the most limited scope possible

Although function parameters are not defined inside the block belonging to the function, in most cases, they can be considered to have block scope.

> The exception case is for __function-level exceptions__ (think about scala annotation `@throws(classOf[Exception])` on method definition)

## 4.2 Global variables and linkage

Variables declared outside of a function are called global variables.

Global variables have __static duration__, which means they are created when the program starts and are destroyed when it ends. Global variables have __file scope (also informally called “global scope” or “global namespace scope”)__, which means they are visible until the end of the file in which they are declared.

The global scope operator (`::`) can be used to tell the compiler you mean the global version instead of the local version.

```cpp
#include <iostream>
int value(5); // global variable

int main()
{
    int value = 7; // hides the global variable value
    value++; // increments local value, not global value
    ::value--; // decrements global value, not local value

    std::cout << "global value: " << ::value << "\n";
    std::cout << "local value: " << value << "\n";
    return 0;
} // local value is destroyed
```

#### linkage

In addition to scope and duration, variables have a third property: linkage. A variable’s linkage __determines whether multiple instances of an identifier refer to the same variable or not__.


A variable with no linkage can only be referred to from the limited scope it exists in.

Normal local variables are an example of variables with no linkage.

__Two local variables with the same name but defined in different functions have no linkage__ -- each will be considered an independent variable.

#### internal linkage

A variable with internal linkage is called an __internal variable (or static variable)__. Variables with internal linkage can be used anywhere __within the file they are defined in, but can not be referenced outside the file they exist in__.

we can use the `static` keyword to make a global variable internal (able to be used only within a single file):

```cpp
static int g_x; // g_x is static, and can only be used within this file

int main()
{
    return 0;
}
```

#### external linkage

A variable with external linkage is called an external variable. Variables with external linkage can be used both in the file they are defined in, as well as in other files.

we can use the `extern` keyword to do so

```cpp
extern double g_y(9.8); // g_y is external, and can be used by other files

// Note: those other files will need to use a forward declaration to access this external variable
// We'll discuss this in the next section

int main()
{
    return 0;
}
```

By default, __non-const variables declared outside of a function are assumed to be external. However, const variables (with `const` keyword) declared outside of a function are assumed to be internal__.

### Variable forward declarations via the extern keyword

Similarly to use a function forward declaration, in order to use an external global variable that has been declared in another file, __you must use a variable forward declaration__.

__For variables, creating a forward declaration is done via the `extern` keyword (with no initialization value)__.

```cpp
/* global.cpp */
// define two global variables
// non-const globals have external linkage by default
int g_x; // external linkage by default
extern int g_y(2); // external linkage by default, so this extern is redundant and ignored

// in this file, g_x and g_y can be used anywhere beyond this point

/* main.cpp */
extern int g_x; // forward declaration for g_x (defined in global.cpp) -- g_x can now be used beyond this point in this file

int main()
{
    extern int g_y; // forward declaration for g_y (defined in global.cpp) -- g_y can be used beyond this point in main() only

    g_x = 5;
    std::cout << g_y; // should print 2

    return 0;
}
```

> Note that this means the `extern` keyword has different meanings in different contexts.
>
> In some contexts, extern means “give this variable external linkage”.
>
> In other contexts, extern means “this is a forward declaration for an external variable that is defined somewhere else”.

If the variable forward declaration is __declared outside of a function, it applies for the whole file__. If the variable forward declaration is declared __inside a function, it applies within that block only__.

> If a variable is declared as __static__, trying to use a forward declaration to access it will not work:

```cpp
// constants.cpp:
static const double g_gravity(9.8);

// main.cpp
#include <iostream>

extern const double g_gravity; // This will satisfy the compiler that g_gravity exists

int main()
{
    std:: cout << g_gravity; // This will cause a linker error because the only definition of g_gravity is inaccessible from here
    return 0;
}
```

### Function linkage

Functions have the same linkage property that variables do.

__Functions always default to external linkage, but can be set to internal linkage via the `static` keyword__:

```cpp
// This function is declared as static, and can now be used only within this file
// Attempts to access it via a function prototype will fail
static int add(int x, int y)
{
    return x + y;
}
```

#### The one-definition rule and non-external linkage

We noted that the one-definition rule says that an object or function can’t have more than one definition, either within a file or a program.

It’s worth noting that __non-extern objects and functions in different files are considered to be different entities__, even if their names and types are identical. This makes sense, since they can’t be seen outside of their respective files anyway.

#### File scope vs. global scope

Technically, in C++, all global variables in C++ have __file scope__.

Informally, the term __file scope is more often applied to file scope variables with internal linkage only__, and __global scope” to file scope variables with external linkage__.

#### Global symbolic constants

A symbolic constant is a name given to a constant literal value.

```cpp
#define MAX_STUDENTS_PER_CLASS 30
#define MAX_NAME_LENGTH 30

int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;
setMax(MAX_NAME_LENGTH);
```
In this case, it’s clear that `MAX_STUDENTS_PER_CLASS` and `MAX_NAME_LENGTH` are intended to be independent values, even though they happen to share the same value `30`.

#### why not use `#define` symbolic constant

> `#defined` symbolic constants do not show up in the debugger (which shows you your actual code). So although the compiler would compile:
> `int max_students = numClassrooms * 30;`
>
> in the debugger you’d see:
> `int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;`
>
> `#defined` values always have file scope (which we’ll talk more about in the section on local and global variables).
>
> This means a value #defined in one piece of code may have a naming conflict with a value `#defined` within the same file later.

1. naming confliction in same file.
2. debug hard, have to lookup where it defined.

> Rule: Avoid using #define to create symbolic constants

A better way to create symbolic constants is through use of `const` (or better, `constexpr`) variables:

```cpp
constexpr int maxStudentsPerClass { 30 };
constexpr int maxNameLength { 30 }

// These will show up in the debugger, and follow all of the normal variable rules around scope.
```

> Rule: use const variables to provide a name and context for your magic numbers.

#### Global symbolic constants

In section 2.9

```cpp
// constants.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

// define your own namespace to hold constants
namespace Constants
{
    const double pi(3.14159);
    const double avogadro(6.0221413e23);
    const double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
    // ... other related constants
}
#endif
```

While this is simple (and fine for smaller programs), every time `constants.h` gets `#included` into a different code file, __each of these variables is copied into the including code file__.

We can avoid this problem __by turning these constants into const global variables, and changing the header file to hold only the variable forward declarations__:

```cpp
// constants.cpp:
namespace Constants
{
    // actual global variables
    extern const double pi(3.14159);
    extern const double avogadro(6.0221413e23);
    extern const double my_gravity(9.2); // m/s^2 -- gravity is light on this planet
}

// constans.h
#ifndef CONSTANTS_H
#define CONSTANTS_H

namespace Constants
{
    // forward declarations only
    extern const double pi;
    extern const double avogadro;
    extern const double my_gravity;
}

#endif

// main.cpp
include "constants.h"
double circumference = 2 * radius * Constants::pi;
```

Because global symbolic constants __should be namespaced (to avoid naming conflicts with other identifiers in the global namespace) and are read-only__, the use of the `g_` prefix is not necessary.

Now the symbolic constants will get instantiated only once (in `constants.cpp`), instead of once every time `constants.h` is `#included`, and the other uses will simply refer to the version in `constants.cpp`.

Any changes made to `constants.cpp` will require recompiling only `constants.cpp`.

However, there are a couple of downsides to doing this.

1. These constants are now considered compile-time constants only within the file they are actually defined in (`constants.cpp`), not anywhere else they are used (now as `run-time constant`).

__This means that outside of `constants.cpp`, they can’t be used anywhere that requires a compile-time constant__(such as for the length of a fixed array).

2. the compiler may not be able to optimize these as much.

> Given the above downsides, we recommend defining your constants in the header file. If you find that for some reason those constants are causing trouble, you can move them into a `.cpp` file as per the above as needed.

#### Summary

```cpp
// Uninitialized definition:
int g_x;        // defines uninitialized global variable (external linkage)
static int g_x; // defines uninitialized static variable (internal linkage)
const int g_x;  // not allowed: const variables must be initialized

// Forward declaration via extern keyword:
extern int g_z;       // forward declaration for global variable defined elsewhere
extern const int g_z; // forward declaration for const global variable defined elsewhere

// Initialized definition:
int g_y(1);        // defines initialized global variable (external linkage)
static int g_y(1); // defines initialized static variable (internal linkage)
const int g_y(1);  // defines initialized const variable (internal linkage)

// Initialized definition w/extern keyword:
extern int g_w(1);       // defines initialized global variable (external linkage, extern keyword is redundant in this case)
extern const int g_w(1); // defines initialized const global variable (external linkage)
```

## 4.3 Static duration variables

Using the `static` keyword on local variables changes them __from automatic duration to static duration (also called fixed duration)__.

A static duration variable (also called a “static variable”) is one that retains its value even after the scope in which it has been created has been exited!

__Static duration variables are only created (and initialized) once, and then they are persisted throughout the life of the program__.

```cpp
#include <iostream>

void incrementAndPrint()
{
    static int s_value = 1;     // static duration via static keyword.  This line is only executed once.
    ++s_value;
    std::cout << s_value << '\n';
} // s_value is not destroyed here, but becomes inaccessible

int main()
{
    incrementAndPrint();
    incrementAndPrint();
    incrementAndPrint();

    return 0;
}

// output:
// 2
// 3
// 4
```

## 4.3 Scope, duration, and linkage summary

https://www.learncpp.com/cpp-tutorial/4-3a-scope-duration-and-linkage-summary/

^ A must-check list.

## 4.3b Namespace

A naming conflict occurs when two identifiers are introduced into the same scope, and the compiler can’t disambiguate which one to use.

A __namespace defines an area of code in which all identifiers are guaranteed to be unique__. By default, global variables and normal functions are defined in the global namespace.

Accessing a namespace with the scope resolution operator `::`.

Multiple namespace blocks with the same name allowed

```cpp
// add.h
namespace BasicMath
{
    // function add() is part of namespace BasicMath
    int add(int x, int y)
    {
        return x + y;
    }
}

// subtract.h
namespace BasicMath
{
    // function subtract() is also part of namespace BasicMath
    int subtract(int x, int y)
    {
        return x - y;
    }
}

// main.cpp
#include "add.h" // import BasicMath::add()
#include "subtract.h" // import BasicMath::subtract()

int main()
{
    std::cout << BasicMath::add(4, 3) << '\n';
    std::cout << BasicMath::subtract(4, 3) << '\n';

    return 0;
}
```

nested namespace:

```cpp
#include <iostream>

namespace Foo
{
    namespace Goo // Goo is a namespace inside the Foo namespace
    {
        const int g_x = 5;
    }
}

int main()
{
    std::cout << Foo::Goo::g_x;
    return 0;
}

// in c++ 17
#include <iostream>

namespace Foo::Goo // Goo is a namespace inside the Foo namespace (C++17 style)
{
    const int g_x = 5;
}

int main()
{
    std::cout << Foo::Goo::g_x;
    return 0;
}
```

Namespace aliases:

```cpp
namespace Boo = Foo::Goo; // Boo now refers to Foo::Goo

int main()
{
  std::cout << Boo::g_x; // This is really Foo::Goo::g_x
  return 0;
}
```

## 4.3c `using` statements

#### The using declaration

```cpp
#include <iostream>

int main()
{
   using std::cout; // this using declaration tells the compiler that cout should resolve to std::cout
   cout << "Hello world!"; // so no std:: prefix is needed here!
   return 0;
}
```

#### The using directive

```cpp
#include <iostream>

int main()
{
   using namespace std; // this using directive tells the compiler that we're using everything in the std namespace!
   cout << "Hello world!"; // so no std:: prefix is needed here!
   return 0;
}
```

The using directive `using namespace std;` tells the compiler that we want to use everything in the `std` namespace, so if the compiler finds a name it doesn’t recognize, it will check the `std` namespace.

#### ambiguous definition

```cpp
#include <iostream> // imports the declaration of std::cout

int cout() // declares our own "cout" function
{
    return 5;
}

int main()
{
    using namespace std; // makes std::cout accessible as "cout"
    cout << "Hello, world!"; // uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
```

we could fix this by explicitly call with `::`, or __using declaration__:

```cpp
using std::cout; // tell the compiler that cout means std::cout
cout << "Hello, world!"; // so this means std::cout
```

The using declaration `using std::cout;` tells the compiler that we’re going to be using the object `cout` from the `std` namespace. So whenever it sees `cout`, it will assume that we mean `std::cout`.

__If there’s a naming conflict between `std::cout` and some other use of `cout`, `std::cout` will be preferred__.

> Rule: Avoid `using` statements outside of a function (in the global scope).
>
> Suggestion: We recommend you avoid `using directives` entirely.

### Cancelling or replacing a using statement

Once a using statement has been declared, __there’s no way to cancel or replace it with a different using statement within the scope in which it was declared__.

```cpp
int main()
{
    using namespace Foo;

    // there's no way to cancel the "using namespace Foo" here!
    // there's also no way to replace "using namespace Foo" with a different using statement

    return 0;
} // using namespace Foo ends here
```

can only intentionally limit the scope of the using statement from:

```cpp
int main()
{
    {
        using namespace Foo;
        // calls to Foo:: stuff here
    } // using namespace Foo expires

    {
        using namespace Goo;
        // calls to Goo:: stuff here
    } // using namespace Goo expires

    return 0;
}
```

## 4.4 Type Conversion

1. implicit type conversion - type coercion
2. explicit type conversion - type casting

#### C-style casts

via the `()` operator:

```cpp
int i1 = 10;
int i2 = 4;
float f = (float)i1 / i2;
```

Because __C-style casts are not checked by the compiler at compile time__, C-style casts can be inherently misused, because they will let you do things that may not make sense, such as getting rid of a const or changing a data type without changing the underlying representation (leading to garbage results).

> Rule: Avoid C-style casts

#### static_cast

```cpp
char c = 'a';
std::cout << static_cast<int>(c) << std::endl; // prints 97, not 'a'

int i1 = 10;
int i2 = 4;
float f = static_cast<float>(i1) / i2;
```

The main advantage of static_cast is that it provides compile-time type checking.

## 4.4b `std::string`

```cpp
#include <string>
#include <iostream>

int main()
{
    std::cout << "Enter your full name: ";
    std::string name;
    std::cin >> name; // this won't work as expected since std::cin breaks on whitespace

    std::cout << "Enter your age: ";
    std::string age;
    std::cin >> age;

    std::cout << "Your name is " << name << " and your age is " << age;
}

// output
// Enter your full name: John Doe
// Enter your age: Your name is John and your age is Doe
```

> operator ``>>`` only returns characters up to the first whitespace it encounters. Any other characters are left inside `cin`, waiting for the next extraction.

Use `std::getline()` to input text

```cpp
std::cout << "Enter your full name: ";
std::string name;
std::getline(std::cin, name); // read a full line of text into name

std::cout << "Enter your age: ";
std::string age;
std::getline(std::cin, age); // read a full line of text into age

std::cout << "Your name is " << name << " and your age is " << age;
```

Mixing inputs with both `std::cin` and `std::getline` may cause some unexpected behavior.

`cin` actually gets the string "2\n" with new line char. It then extracts the `2` to variable `choice`, leaving the newline stuck in the input stream. Then, __when `std::getline()` goes to read the name, it sees ``\n` is already in the stream__, and figures we must have entered an empty string!

> A good rule of thumb is that after reading a value with `std::cin`, remove the newline from the stream.

```cpp
int main()
{
  std::cout << "Pick 1 or 2: ";
  int choice { 0 };
  std::cin >> choice;

  std::cin.ignore(32767, '\n'); // ignore up to 32767 characters until a \n is removed

  std::cout << "Now enter your name: ";
  std::string name;
  std::getline(std::cin, name);

  std::cout << "Hello, " << name << ", you picked " << choice << '\n';

  return 0;
}

// instead of cin.ignore, use better one
#include <limits>
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // ignore unlimited characters until a \n is removed
```

## 4.5 Enumeration

An enumerated type (also called an enumeration) is a data type where every possible value is defined as a symbolic constant (called an enumerator).

```cpp
// Define a new enumeration named Color
enum Color
{
    // Here are the enumerators
    // These define all the possible values this type can hold
    // Each enumerator is separated by a comma, not a semicolon
    COLOR_BLACK,
    COLOR_RED,
    COLOR_BLUE,
    COLOR_GREEN,
    COLOR_WHITE,
    COLOR_CYAN,
    COLOR_YELLOW,
    COLOR_MAGENTA, // see note about trailing comma on the last enumerator below
}; // however the enum itself must end with a semicolon

// Define a few variables of enumerated type Color
Color paint = COLOR_WHITE;
Color house(COLOR_BLUE);
Color apple { COLOR_RED };
```

__Defining an enumeration (or any user-defined data type) does not allocate any memory__. When a variable of the enumerated type is defined (such as variable paint in the example above), memory is allocated for that variable at that time.

> when an l-value assigned to enum r-value, memory allocated.

#### Enumerator values

__Each enumerator is automatically assigned an integer value based on its position in the enumeration list__, value default start from 0. It can be assigned.

```cpp
Color paint(COLOR_WHITE);
std::cout << paint;

// output
// 4
```

These integer values can be positive or negative and can share the same value as other enumerators. __Any non-defined enumerators are given a value one greater than the previous enumerator__.

```cpp
// define a new enum named Animal
enum Animal
{
    ANIMAL_CAT = -3,
    ANIMAL_DOG, // assigned -2
    ANIMAL_PIG, // assigned -1
    ANIMAL_HORSE = 5,
    ANIMAL_GIRAFFE = 5, // shares same value as ANIMAL_HORSE
    ANIMAL_CHICKEN // assigned 6
};
```

Note in this case, `ANIMAL_HORSE` and `ANIMAL_GIRAFFE` have been given the same value. When this happens, the enumerations become non-distinct. essentially, `ANIMAL_HORSE` and `ANIMAL_GIRAFFE` are interchangeable

> Rule: Don’t assign the same value to two enumerators in the same enumeration unless there’s a very good reason.

Because enumerated values evaluate to integers, they can be assigned to integer variables. This means they can also be output (as integers), since `std::cout` knows how to output integers.

```cpp
int mypet = ANIMAL_PIG;
std::cout << ANIMAL_HORSE; // evaluates to integer before being passed to std::cout

// output: 5
```

assign enumerators from one enum type to another enum type will cause a compile error, or workaround by casting from `int`:

```cpp
Animal animal = 5; // will cause compiler error

Color color = static_cast<Color>(5); // ugly
```

The compiler also will not let you input an enum using `std::cin` due to disallowed type coercion, but once again, `static_cast` to enum type from `int` would be accepted.

__Each enumerated type is considered a distinct type__. Consequently, trying to assign enumerators from one enum type to another enum type will cause a compile error:

```cpp
// COLOR_BLUE is from enum Color
Animal animal = COLOR_BLUE; // will cause compiler error
```

Enum is good as a replacement for magic number switch/case, conditional branch handling.

## 4.5a Enum Class

This is definitely not as desired since `color` and `fruit` are from different enumerations and are not intended to be comparable!

With standard enumerators, there’s no way to prevent comparing enumerators from different enumerations.

C++11 defines a new concept, the `enum class` (also called a scoped enumeration), __which makes enumerations both strongly typed and strongly scoped__.

```cpp
#include <iostream>
int main()
{
    enum class Color // "enum class" defines this as a scoped enumeration instead of a standard enumeration
    {
        RED, // RED is inside the scope of Color
        BLUE
    };

    enum class Fruit
    {
        BANANA, // BANANA is inside the scope of Fruit
        APPLE
    };

    Color color = Color::RED; // note: RED is not directly accessible any more, we have to use Color::RED
    Fruit fruit = Fruit::BANANA; // note: BANANA is not directly accessible any more, we have to use Fruit::BANANA

    if (color == fruit) // compile error here, as the compiler doesn't know how to compare different types Color and Fruit
        std::cout << "color and fruit are equal\n";
    else
        std::cout << "color and fruit are not equal\n";

    return 0;
}
```

also the type coercion from scoped enum type to `int` is unavailable, only casting allowed.

> Also, just in case you ever run into it, __enum struct__ is equivalent to __enum class__. But this usage is not recommended and is not commonly used.

## 4.6 Typedefs and type aliases

Typedefs allow the programmer to create an alias for a data type, and use the aliased name instead of the actual type name.

```cpp
typedef double distance_t; // define distance_t as an alias for type double

// The following two statements are equivalent:
double howFar;
distance_t howFar;
```

By convention, typedef names are declared using a `_t` suffix.

#### Using typedefs for legibility

Data type names such as `char`, `int`, `long`, `double`, and `bool` are good for describing what type a function returns, but more often we want to know what purpose a return value serves.

```cpp
typedef int testScore_t;
testScore_t GradeTest();
```

#### Using typedefs for easier code maintenance

Precaution is necessary when changing the type of a typedef to a type in a different type family.

One big advantage of typedefs is that they can be used to hide platform specific details. On some platforms, an integer is 2 bytes, and on others, it is 4. Thus, using int to store more than 2 bytes of information can be potentially dangerous when writing platform independent code.

```cpp
#ifdef INT_2_BYTES
typedef char int8_t;
typedef int int16_t;
typedef long int32_t;
#else
typedef char int8_t;
typedef short int16_t;
typedef int int32_t;
#endif
```

On machines where integers are only 2 bytes, `INT_2_BYTES` can be `#defined`, and the program will be compiled with the top set of typedefs. On machines where integers are 4 bytes, leaving `INT_2_BYTES` undefined will cause the bottom set of typedefs to be used.

In C++11, this is actually how the fixed width integers (like `int8_t`) were defined! As a side-effect of the fact that `int8_t` is actually a typedef of `char`, the following code acts somewhat unexpectedly:

```cpp
#include <cstdint> // for fixed-width integers
#include <iostream>

int main()
{
    std::int8_t i(97); // int8_t is actually a typedef for char
    std::cout << i;

    return 0;
}
// output: a
```

not `97`, because `std::cout` prints char as an ASCII character, not a number.

#### Using typedefs to make complex types simple

```cpp
// original
std::vector<std::pair<std::string, int> > pairlist;

bool hasDuplicates(std::vector<std::pair<std::string, int> > pairlist)
{
    // some code here
}

// with typedef
typedef std::vector<std::pair<std::string, int> > pairlist_t; // make pairlist_t an alias for this crazy type

pairlist_t pairlist; // instantiate a pairlist_t

bool hasDuplicates(pairlist_t pairlist) // use pairlist_t in a function parameter
{
    // some code here
}
```

#### Type aliases in C++11

1. It’s easy to forget whether the type name or type definition come first.

2. The syntax for typedefs gets ugly with more complex types.

In C++11, this can be declared as:

```cpp
typedef double distance_t; // define distance_t as an alias for type double

// c++ 11 syntax
using distance_t = double; // define distance_t as an alias for type double
```

> Rule: Favor type aliases over typedefs if your compiler is C++11 compatible.

## 4.7 Struct

C++ allows us to create our own user-defined aggregate data types.

An aggregate data type is a data type that groups multiple individual variables together. One of the simplest aggregate data types is the `struct`.

A struct (short for structure) allows us to group variables of mixed data types together into a single unit.

```cpp
struct Employee
{
    short id;
    int age;
    double wage;
};
```

Keep in mind that `Employee` is just a declaration, even though we are telling the compiler that the struct will have member variables, __no memory is allocated at this time__. By convention, struct names start with a capital letter to distinguish them from variable names.

> Warning: One of the easiest mistakes to make in C++ is to forget the semicolon at the end of a struct declaration. This will cause a compiler error on the next line of code.

#### Accessing struct members

In order to access the individual members, we use the `member selection operator`__(which is a period)__.

#### Initializing structs

```cpp
struct Employee
{
    short id;
    int age;
    double wage;
};

Employee joe = { 1, 32, 60000.0 }; // joe.id = 1, joe.age = 32, joe.wage = 60000.0
Employee frank = { 2, 28 }; // frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)

// In C++11, we can also use uniform initialization:
Employee joe { 1, 32, 60000.0 };
// joe.id = 1, joe.age = 32, joe.wage = 60000.0

Employee frank { 2, 28 };
// frank.id = 2, frank.age = 28, frank.wage = 0.0 (default initialization)
```

#### C++11/14: Non-static member initialization

Starting with C++11, it’s possible to give non-static (normal) struct members a default value:

```cpp
struct Rectangle
{
    double length = 1.0;
    double width = 1.0;
};

int main()
{
    Rectangle x; // length = 1.0, width = 1.0

    x.length = 2.0; // you can assign other values like normal

    return 0;
}
```

Unfortunately, in C++11, __the non-static member initialization syntax is incompatible with the initializer list and uniform initialization syntax__. You’ll have to decide whether you want to use non-static member initialization or uniform initialization.

> Uniform initialization is more flexible, so we recommend sticking with that one.

```cpp
// this won't compile
struct Rectangle
{
  double length = 1.0; // non-static member initialization
  double width = 1.0;
};

int main()
{
  Rectangle x{ 2.0, 2.0 }; // uniform initialization

  return 0;
}
```

However, in C++14, this restriction was lifted and both can be used.

#### Assigning to structs

```cpp
struct Employee
{
    short id;
    int age;
    double wage;
};

Employee joe;
joe = { 1, 32, 60000.0 }; // C++11 only
/* prior to C++11 have to assign separately
  joe.id = 1;
  joe.age = 32;
  joe.wage = 60000.0;
*/
```

#### Nested structs

Structs can contain other structs.

```cpp
struct Employee
{
    short id;
    int age;
    double wage;
};

struct Company
{
    Employee CEO; // Employee is a struct within the Company struct
    int numberOfEmployees;
};

Company myCompany = {{ 1, 42, 60000.0f }, 5 };
```

#### Struct size and data structure alignment

we can expect `Employee` struct should have 2 + 4 + 8 = 14 bytes, but actually we should use the `sizeof` operator:

```cpp
struct Employee
{
    short id;
    int age;
    double wage;
};

int main()
{
    std::cout << "The size of Employee is " << sizeof(Employee) << "\n";

    return 0;
}

// The size of Employee is 16
```

we can only say that the size of a struct __will be at least as large as the size of all the variables it contains. But it could be larger__! For performance reasons, the compiler will sometimes add gaps into structures (this is called __padding__).

#### Accessing structs across multiple files

Because struct declarations do not take any memory, if you want to share a struct declaration across multiple files (so you can instantiate variables of that struct type in multiple files), __put the struct declaration in a header file, and #include that header file anywhere you need it__.

Struct variables are subject to the same rules as normal variables. Consequently, __to make a struct variable accessible across multiple files, you can use the `extern` keyword to do so__.

## 4.8 `auto` keyword

The auto keyword was a way to explicitly specify that a variable should have automatic duration:

```cpp
int main()
{
  auto int foo(5); // explicitly specify that foo should have automatic duration

  return 0;
}
```

__Since all variables in modern C++ default to automatic duration unless otherwise specified, the `auto` keyword was superfluous, and thus obsolete__.

#### Type inference in C++11

In C++11, the meaning of the auto keyword has changed.

Starting with C++11, the `auto` keyword does just that. When initializing a variable, the `auto` keyword can be used in place of the variable type to tell the compiler to infer the variable’s type from the initializer’s type. This is called __type inference (also sometimes called type deduction)__.

```cpp
auto d = 5.0; // 5.0 is a double literal, so d will be type double
auto i = 1 + 2; // 1 + 2 evaluates to an integer, so i will be type int

// This even works with the return values from functions:
int add(int x, int y)
{
    return x + y;
}

int main()
{
    auto sum = add(5, 6);
    // add() returns an int, so sum will be type int
    return 0;
}
```

> __The `auto` keyword can’t be used with function parameters__

```cpp
#include <iostream>

// compile error
void addAndPrint(auto x, auto y)
{
    std::cout << x + y;
}
```

#### Type inference for functions in C++14

In C++14, the `auto` keyword was extended to be able to auto-deduce a function’s return type. Consider:

```cpp
auto add(int x, int y)
{
    return x + y;
}
```

> but we should avoid this to make function definition with clear return type instead.

#### Trailing return type syntax in C++11

C++11 also added the ability to use a trailing return syntax, __where the return type is specified after the rest of the function prototype__.

```cpp
int add(int x, int y);

// equivalent in C++11
auto add(int x, int y) -> int;
```

__In this case, auto does not perform type inference, it is just part of the syntax to use a trailing return type__.

Why would you want to use this?

One nice thing is that it makes all of your function names line up:

```cpp
auto add(int x, int y) -> int;
auto divide(double x, double y) -> double;
auto printSomething() -> void;
auto generateSubstring(const std::string &s, int start, int len) -> std::string;
```

But it is of more use when combined with some advanced C++ features, such as classes and the decltype keyword.

For now, we recommend the continued use of the traditional function return syntax.

## 6.6 C-style strings

A C-style string is simply an array of characters that uses a null terminator.

A null terminator is a special character (`\0`, ascii code `0`) used to indicate the end of the string. More generically, A __C-style string is called a null-terminated string__.

```cpp
#include <iostream>
#include <iterator> // for std::size

int main()
{
    char myString[] = "string";
    const int length = std::size(myString);
    //  const int length = sizeof(myString) / sizeof(myString[0]);
    // use instead if not C++17 capable

    std::cout << myString<< " has " << length << " characters.\n";
    for (int index = 0; index < length; ++index)
        std::cout << static_cast<int>(myString[index]) << " ";

    return 0;
}

/*
string has 7 characters.
115 116 114 105 110 103 0
*/
```

When declaring strings in this manner, __it is a good idea to use `[]` and let the compiler calculate the length of the array__. That way if you change the string later, you won’t have to manually adjust the array length.

One important point to note is that __C-style strings follow all the same rules as arrays__. This means you can initialize the string upon creation, __but you can not assign values to it using the assignment operator after that!__

```cpp
char myString[] = "string"; // ok
myString = "rope"; // not ok!
```

When printing a C-style string, `std::cout` prints characters __until it encounters the null terminator__.

If you accidentally overwrite the null terminator in a string (e.g. by assigning something to `myString[6]`), __you’ll not only get all the characters in the string, but `std::cout` will just keep printing everything in adjacent memory slots until it happens to hit a `0`!__

```cpp
#include <iostream>

int main()
{
    char name[20] = "Alex";
    // only use 5 characters (4 letters + null terminator)
    std::cout << "My name is: " << name << '\n';

    return 0;
}
```

n this case, the string __Alex__ will be printed, and __`std::cout` will stop at the null terminator. The rest of the characters in the array are ignored__.

#### `std::cin`

```cpp
#include <iostream>

int main()
{
    char name[255];
    // declare array large enough to hold 255 characters
    std::cout << "Enter your name: ";
    std::cin >> name;
    std::cout << "You entered: " << name << '\n';

    return 0;
}
```

it is poor programming practice, because nothing is stopping the user from entering more than 255 characters.

use `std::getline` instead:

```cpp
#include <iostream>
int main()
{
    char name[255]; // declare array large enough to hold 255 characters
    std::cout << "Enter your name: ";
    std::cin.getline(name, 255);
    std::cout << "You entered: " << name << '\n';

    return 0;
}
```

This call to `cin.getline()` will read up to 254 characters into name (__leaving room for the null terminator!). Any excess characters will be discarded__.

#### Manipulating C-style strings

by `cstring.h` lib:

```cpp
#include <cstring>
int main()
{
    char source[] = "Copy this!";
    char dest[50];
    strcpy(dest, source);
    std::cout << dest; // prints "Copy this!"

    return 0;
}
```

However, `strcpy()` can easily cause array overflows if you’re not careful!

Use `strncpy()` instead, which allows you to specify the size of the buffer, and ensures overflow doesn’t occur. Unfortunately, __`strncpy()` doesn’t ensure strings are null terminated, which still leaves plenty of room for array overflow__.

In C++11, `strcpy_s()` is preferred, which adds a new parameter to define the size of the destination. However, not all compilers support this function, and to use it, you have to define __STDC_WANT_LIB_EXT1__ with integer value 1.

```cpp
#define __STDC_WANT_LIB_EXT1__ 1
#include <cstring> // for strcpy_s
int main()
{
    char source[] = "Copy this!";
    char dest[5]; // note that the length of dest is only 5 chars!
    strcpy_s(dest, 5, source); // An runtime error will occur in debug mode
    std::cout << dest;

    return 0;
}

// strlcpy() is a popular alternative
```

Another useful function is the strlen() function, which returns the length of the C-style string (__without the null terminator__).

```cpp
#include <iostream>
#include <cstring>
#include <iterator> // for std::size

int main()
{
    char name[20] = "Alex"; // only use 5 characters (4 letters + null terminator)
    std::cout << "My name is: " << name << '\n';
    std::cout << name << " has " << strlen(name) << " letters.\n";
    std::cout << name << " has " << std::size(name) << " characters in the array.\n"; // use sizeof(name) / sizeof(name[0]) if not C++17 capable

    return 0;
}

/*
My name is: Alex
Alex has 4 letters.
Alex has 20 characters in the array.
*/

/*
Other useful functions:
strcat()
Appends one string to another (dangerous)

strncat()
Appends one string to another (with buffer length check)

strcmp()
Compare two strings (returns 0 if equal)

strncmp()
Compare two strings up to a specific number of characters (returns 0 if equal)
 */
```

Don’t use C-style strings if `std::string` applicable.

## 6.7 Pointers

The size of a pointer is dependent upon the architecture the executable is compiled for, __a 32-bit executable uses 32-bit memory addresses__.

```cpp
char *chPtr; // chars are 1 byte
int *iPtr; // ints are usually 4 bytes
struct Something
{
    int nX, nY, nZ;
};
Something *somethingPtr; // Something is probably 12 bytes

std::cout << sizeof(chPtr) << '\n'; // prints 4
std::cout << sizeof(iPtr) << '\n'; // prints 4
std::cout << sizeof(somethingPtr) << '\n'; // prints 4
```

Should care about the segmentation fault issue.

## 6.7a Null Pointers

Besides memory addresses, there is one additional value that a pointer can hold: a `null` value. A `null` value is a special value that means the pointer is not pointing at anything.

A pointer holding a null value is called a __null pointer__.

In C++, we can assign a pointer a null value __by initializing or assigning it the literal `0`__:

```cpp
float *ptr { 0 };  // ptr is now a null pointer

float *ptr2; // ptr2 is uninitialized
ptr2 = 0; // ptr2 is now a null pointer

// Pointers convert to boolean false if they are null
// Therefore, we can test whether a pointer is null or not:

if (ptr)
    cout << "ptr is pointing to a double value.";
else
    cout << "ptr is a null pointer.";
```

> Best practice: Initialize your pointers to a null value if you’re not giving them another value.

#### Dereferencing null pointers

Dereferencing a null pointer also results in undefined behavior. __In most cases, it will crash your application__.

#### The NULL macro

In C++, there is a special preprocessor macro called `NULL` (defined in the `<cstddef>` header). This macro was inherited from C, where it is commonly used to indicate a null pointer.

```cpp
#include <cstddef> // for NULL

double *ptr { NULL }; // ptr is a null pointer
```

Note that the value of `0` isn’t a pointer type, so assigning `0` (or `NULL`, pre-C++11) to a pointer to denote that the pointer is a null pointer is a little inconsistent.

In rare cases, when used as a literal argument, __it can even cause problems because the compiler can’t tell whether we mean a null pointer or the integer `0`__:

```cpp
#include <iostream>
#include <cstddef> // for NULL

void print(int x)
{
  std::cout << "print(int): " << x << '\n';
}

void print(int *x)
{
  if (!x)
    std::cout << "print(int*): null\n";
  else
    std::cout << "print(int*): " << *x << '\n';
}

int main()
{
  int *x { NULL };
  print(x);
  // calls print(int*) because x has type int*
  print(0);
  // calls print(int) because 0 is an integer literal
  print(NULL);
  // likely calls print(int), although we probably wanted print(int*)

  return 0;
}
```

To address the above issues, C++11 introduces a new keyword called `nullptr`. `nullptr` is both a keyword and an __rvalue constant__, much like the boolean keywords true and false are.

```cpp
int *ptr { nullptr };
// note: ptr is still an integer pointer, just set to a null value
```

nullptr is implicitly converted to an integer pointer, and then the value of `nullptr` assigned to `ptr`. This has the effect of making integer pointer `ptr` a null pointer.

> Best practice: With C++11, use nullptr to initialize your pointers to a null value.

#### `std::nullptr_t` in C++11

C++11 also introduces a new type called `std::nullptr_t` (in header `<cstddef>`). `std::nullptr_t` can only hold one value: `nullptr`!

While this may seem kind of silly, it’s useful in one situation. If we want to write a function that accepts only a nullptr argument, what type do we make the parameter? The answer is `std::nullptr_t`.

```cpp
#include <iostream>
#include <cstddef> // for std::nullptr_t

void doSomething(std::nullptr_t ptr)
{
    std::cout << "in doSomething()\n";
}

int main()
{
    doSomething(nullptr); // call doSomething with an argument of type std::nullptr_t

    return 0;
}
```

## 6.8 Array Decays to Pointer

When a fixed array is used in an expression, __the fixed array will _decay_ (be implicitly converted) into a pointer that points to the first element of the array__.

```cpp
#include <iostream>

int main()
{
    int array[5] = { 9, 7, 5, 3, 1 };

    // print address of the array's first element
    std::cout << "Element 0 has address: " << &array[0] << '\n';

    // print the value of the pointer the array decays to
    std::cout << "The array decays to a pointer holding address: " << array << '\n';

    return 0;
}

/*
Element 0 has address: 0042FD5C
The array decays to a pointer holding address: 0042FD5C
 */
```

All elements of the array can still be accessed through the pointer (we’ll see how this works in the next lesson), __but information derived from the array’s type (such as how long the array is) can not be accessed from the pointer__.

```cpp
int array[5] = { 9, 7, 5, 3, 1 };

// dereferencing an array returns the first element (element 0)
cout << *array; // will print 9!

char name[] = "Jason"; // C-style string (also an array)
cout << *name; // will print 'J'
```

Note that we’re not actually dereferencing the array itself.

The array (of type `int[5]`) gets implicitly converted into a pointer (of type `int *`), and we dereference the pointer to get the value at the memory address the pointer is holding (the value of the first element of the array).

#### Differences between pointers and fixed arrays

The primary difference occurs when using the `sizeof()` operator. __When used on a fixed array, `sizeof` returns the size of the entire array (array length `*` element size)__. When used on a pointer, `sizeof` returns the size of a memory address (in bytes).

```cpp
#include <iostream>

int main()
{
  int array[5] = { 9, 7, 5, 3, 1 };

  std::cout << sizeof(array) << '\n';
  // will print sizeof(int) * array length
  int* ptr = array;
  std::cout << sizeof(ptr) << '\n';
  // will print the size of a pointer

  return 0;
}
// 20
// 4
```

The second difference occurs when using the address-of operator (`&`). Taking the address of a pointer yields the memory address of the pointer variable.

Taking the address of the array returns a pointer to the entire array. This pointer also points to the first element of the array, __but the type information is different (in the above example, `int(*)[5]`)__.

#### Revisiting passing fixed arrays to functions

we mentioned that because copying large arrays can be very expensive, C++ does not copy an array when an array is passed into a function. __When passing an array as an argument to a function, a fixed array decays into a pointer, and the pointer is passed to the function__:

```cpp
#include <iostream>

void printSize(int *array)
{
    // array is treated as a pointer here
    std::cout << sizeof(array) << '\n'; // prints the size of a pointer, not the size of the array!
}

int main()
{
    int array[] = { 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) << '\n'; // will print sizeof(int) * array length

    printSize(array); // the array argument decays into a pointer here

     return 0;
}

// 32
// 4

// Note that this happens even if the parameter is declared as a fixed array:

#include <iostream>

// C++ will implicitly convert parameter array[] to *array
void printSize(int array[])
{
    // array is treated as a pointer here, not a fixed array
    std::cout << sizeof(array) << '\n'; // prints the size of a pointer, not the size of the array!
}

int main()
{
    int array[] = { 1, 1, 2, 3, 5, 8, 13, 21 };
    std::cout << sizeof(array) << '\n'; // will print sizeof(int) * array length

    printSize(array); // the array argument decays into a pointer here

     return 0;
}

// 32
// 4
```

C++ implicitly converts parameters using the array syntax (`[]`) to the pointer syntax (`*`). That means the following two function declarations are identical:

```cpp
void printSize(int array[]);
void printSize(int *array);
```

Some programmers prefer using the `[]` syntax because it makes it clear that the function is expecting an array, not just a pointer to a value.

However, in most cases, __because the pointer doesn’t know how large the array is, you’ll need to pass in the array size as a separate parameter anyway (strings being an exception because they’re null terminated)__.

We lightly recommend using the pointer syntax, because it makes it clear that the parameter is being treated as a pointer, not a fixed array, and that certain operations, such as `sizeof()`, will operate as if the parameter is a pointer.

> Recommendation: Favor the pointer syntax (`*`) over the array syntax (`[]`) for array function parameters.

#### Arrays in structs and classes don’t decay

__Arrays that are part of structs or classes do not decay when the whole struct or class is passed to a function__.

This yields a useful way to prevent decay if desired, and will be valuable later when we write classes that utilize arrays.

#### Arrays are laid out sequentially in memory

When calculating the result of a pointer arithmetic expression, the compiler always multiplies the integer operand by the size of the object being pointed to. This is called __scaling__.

By using the address-of operator (`&`), we can determine that arrays are laid out sequentially in memory. That is, elements 0, 1, 2, … are all adjacent to each other, in order.

It turns out that when the compiler sees the subscript operator (`[]`), __it actually translates that into a pointer addition and dereference__!

__Generalizing, `array[n]` is the same as `*(array + n)`, where `n` is an integer__

## 6.8b C-style String Symbolic Constants

C++ also supports a way to create C-style string symbolic constants using pointers:

```cpp
#include <iostream>

int main()
{
    char myName[] = "Alex";
    // fixed array
    std::cout << myName;

    const char* myName2 = "Alex";
    // pointer to symbolic constant
    std::cout << myName2;

    return 0;
}
```

C++ deals with the memory allocation for these slightly differently.

In the fixed array case, the program allocates memory for a fixed array of length 5, and initializes that memory with the string `Alex\0`.

Because memory has been specifically allocated for the array, you’re free to alter the contents of the array. The array itself is treated __as a normal local variable, so when the array goes out of scope, the memory used by the array is freed up for other uses__.

In the symbolic constant case, how the compiler handles this is implementation defined. __What usually happens is that the compiler places the string `Alex\0` into read-only memory somewhere, and then sets the pointer to point to it__. Because this memory may be read-only, __best practice is to make sure the string is `const`__.

```cpp
const char *name1 = "Alex";
const char *name2 = "Alex";
```

These are two different string literals with the same value.

The compiler may opt to combine these into a single shared string literal, with both `name1` and `name2` pointed at the same address. Thus, __if `name1` was not `const`, making a change to `name1` could also impact `name2` (which might not be expected)__.

As a result of string literals being stored in a fixed location in memory, __string literals have static duration rather than automatic duration (that is, they die at the end of the program, not the end of the block in which they are defined). That means that when we use string literals, we don’t have to worry about scoping issues__. Thus, the following is okay:

```cpp
const char* getName()
{
    return "Alex";
}
```

If this function were returning any other kind of literal by address, the literal would be destroyed at the end of `getName()`, and __we’d return a dangling pointer back to the caller. However, because string literals have static duration, `Alex` will not be destroyed when `getName()` terminates, so the caller can still successfully access it__.

> Rule: Feel free to use C-style string symbolic constants if you need read-only strings in your program, but always make them `const`!

#### `std::cout` and char pointers

At this point, you may have noticed something interesting about the way `std::cout` handles pointers of different types.

Consider the following example:

```cpp
#include <iostream>

int main()
{
    int nArray[5] = { 9, 7, 5, 3, 1 };
    char cArray[] = "Hello!";
    const char* name = "Alex";

    std::cout << nArray << '\n'; // nArray will decay to type int*
    std::cout << cArray << '\n'; // cArray will decay to type char*
    std::cout << name << '\n'; // name is already type char*

    char c = 'Q';
    std::cout << &c;

    return 0;
}
// 003AF738
// Hello!
// Alex
// Q╠╠╠╠╜╡4;¿■A
```

Why did the int array print an address, but the character arrays printed strings?

The answer is that `std::cout` makes some assumptions about your intent. __If you pass it a non-char pointer, it will simply print the contents of that pointer (the address that the pointer is holding)__.

However, __if you pass it an object of type `char*` or `const char*`, it will assume you’re intending to print a string__. Consequently, instead of printing the pointer’s value, it will print the string being pointed to instead!

For `char c`, it assumed `&c` (which has type `char*`) was a string. So it printed the ‘Q’, and then kept going.

Next in memory was a bunch of garbage. __Eventually, it ran into some memory holding a 0 value, which it interpreted as a null terminator__, so it stopped. What you see may be different depending on what’s in memory after variable.

## 6.9

will recheck from 6.9 to 6.16, must check 6.11 reference variables.

- https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in?page=1&tab=votes#tab-top

## 12.2 Virtual functions and polymorphism

will recheck from 12.1 to 12.10

## 13 Templates

will recheck from 13.1 to 13.8
